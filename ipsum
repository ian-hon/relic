,\n};\n\n#[derive(Debug, Clone)]\npub struct Commit {\n    pub id: Option<u32>,\n    pub message: String,\n    pub description: String,\n    pub change: Change,\n    pub timestamp: u64,\n\n    pub author: String,\n}\nimpl Commit {\n    pub fn header(&self) -> String {\n        // \"integrated backwards compatibility\" (2025-5-26 16:30) (affected : change.rs, content.rs, ...)\n\n        let mut file_names = vec![];\n        for (_, parent) in self.change.as_map().1 {\n            for (f, _) in parent {\n                file_names.push(f);\n            }\n        }\n\n        format!(\n            \"({}) \\\"{}\\\" (affected : {}{})\",\n            utils::into_human_readable(self.timestamp),\n            self.message,\n            file_names\n                .iter()\n                .take(5)\n                .map(|x| x.to_string())\n                .collect::<Vec<String>>()\n                .join(\", \"),\n            if file_names.len() > 5 { \", ...\" } else { \"\" }\n        )\n    }\n\n    pub fn serialise(&self) -> String {\n        format!(\n            \"= {} {} {:?} {:?} {}\\n{}\",\n            self.id\n                .map_or(\"LOCAL\".to_string(), |i| format!(\"{:06x}\", i).clone()),\n            self.timestamp,\n            urlencoding::encode(&self.message).to_string(),\n            urlencoding::encode(&self.description).to_string(),\n            self.author,\n            self.change.serialise_changes()\n        )\n    }\n\n    pub fn deserialise(s: String) -> Option<Commit> {\n        // = LOCAL 1747682692319414000 \"initial%20commit\" \"\" no_one\n\n        let lines = s.split(\"\\n\").collect::<Vec<&str>>();\n        if lines.len() < 2 {\n            // return None;\n        }\n\n        let metadata = lines[0].split(\" \").collect::<Vec<&str>>();\n        if metadata.len() != 6 {\n            // return None;\n        }\n\n        let [_, status, time, message, description, author] = *metadata.as_slice() else {\n            return None;\n        };\n\n        Some(Commit {\n            id: status.parse::<u32>().map_or(None, |t| Some(t)),\n            message: urlencoding::decode(&message[1..message.len() - 1].to_string())\n                .unwrap()\n                .to_string(),\n            description: urlencoding::decode(&description[1..description.len() - 1].to_string())\n                .unwrap()\n                .to_string(),\n            change: Change::deserialise_changes(lines[1..].join(\"\\n\")).unwrap_or(Change::empty()),\n            timestamp: time.parse::<u64>().unwrap_or(0),\n            author: author.to_string(),\n        })\n    }\n}\n\npub fn add(_: &mut State, args: &ArgMatches) {\n    let f = args\n        .get_many::<PathBuf>(\"FILE\")\n        .unwrap()\n        .map(|x| x.clone())\n        .collect::<Vec<PathBuf>>();\n\n    let mut result: HashSet<String> = HashSet::from_iter(\n        fs::read_to_string(\"./.relic/tracked\")\n            .unwrap()\n            .split(\"\\n\")\n            .filter(|x| !x.is_empty())\n            .map(|x| x.to_string())\n            .collect::<Vec<String>>(),\n    );\n    for p in f {\n        // TODO : path.join for this? or concatenating / works?\n        result.insert(format!(\n            \"{}{}\",\n            p.to_string_lossy().to_string(),\n            if !p.to_string_lossy().to_string().ends_with(\"/\") && p.is_dir() {\n                \"/\"\n            } else {\n                \"\"\n            }\n        ));\n    }\n    let _ = fs::write(\n        \"./.relic/tracked\",\n        result.drain().collect::<Vec<String>>().join(\"\\n\"),\n    );\n}\n\npub fn remove(s: &mut State, args: &ArgMatches) {\n    let f = args\n        .get_many::<PathBuf>(\"FILE\")\n        .unwrap()\n        .map(|x| x.clone())\n        .collect::<Vec<PathBuf>>();\n\n    let result: HashSet<String> = HashSet::from_iter(\n        fs::read_to_string(\"./.relic/tracked\")\n            .unwrap()\n            .split(\"\\n\")\n            .filter(|x| !x.is_empty())\n            .map(|x| PathBuf::from(\".\").join(x).to_string_lossy().to_string())\n            .collect::<Vec<String>>(),\n    );\n\n    // initialise removed_content\n    let mut removed_content = ContentSet {\n        files: HashSet::from_iter(\n            f.iter()\n                .filter(|x| !x.is_dir())\n                .map(|x| PathBuf::from(\".\").join(x).to_string_lossy().to_string()),\n        ),\n        directories: HashSet::from_iter(\n            f.iter()\n                .filter(|x| x.is_dir())\n                .map(|x| PathBuf::from(\".\").join(x).to_string_lossy().to_string()),\n        ),\n    }\n    .initialise(&mut s.current);\n\n    let mut to_subtract: HashSet<String> = HashSet::from_iter(\n        removed_content\n            .directories\n            .drain()\n            .collect::<Vec<String>>()\n            .into_iter()\n            .map(|x| format!(\"{x}/\"))\n            .collect::<Vec<String>>(),\n    );\n    to_subtract = to_subtract\n        .union(&HashSet::from_iter(removed_content.files.drain()))\n        .map(|x| x.to_string())\n        .collect::<HashSet<String>>();\n\n    // set operations\n    // right join\n    // result - removed_content\n\n    let _ = fs::write(\n        \"./.relic/tracked\",\n        result\n            .difference(&to_subtract)\n            .map(|x| x[2..].to_string())\n            .collect::<Vec<String>>()\n            .join(\"\\n\"),\n    );\n}\n\npub fn commit(state: &mut State, args: &ArgMatches) {\n    // push into pending stage\n    // update upstream\n\n    // everything after the first line will be generated by Change::serialise_change\n    r#\"= {commit id} {unix timestamp of commit} {message} {description} {author}\n+ D \"lorem/ipsum/dolor\"\n+ F \"lorem/ipsum/dolor/earth.txt\" \"earth.txt\"\n- D \"lorem/sit\"\n=\n| \"lorem/ipsum/dolor/earth.txt\"\n+ 3 asdfsdf\n+ 5 sfsdf\n- 7\n| \"lorem/ipsum/saturn/txt\"\n+ 4 lsdfljs\"#;\n    let message = args.get_one::<String>(\"message\").unwrap().clone();\n    let description = args\n        .get_one::<String>(\"description\")\n        .map_or(\"\".to_string(), String::clone);\n\n    let commit = Commit {\n        id: None,\n        message,\n        description,\n        change: state.get_changes(),\n        timestamp: utils::get_time(),\n        author: \"no_one\".to_string(),\n    };\n\n    state.pending_add(commit);\n    // update upstream\n    (*state).update_upstream(&mut state.track_set.clone());\n}\n\npub fn push(_: &mut State, _: &ArgMatches) {}\n\npub fn pull(_: &mut State, _: &ArgMatches) {}\n\npub fn fetch(_: &mut State, _: &ArgMatches) {}\n\npub fn cherry(_: &mut State, _: &ArgMatches) {}\n\npub fn rollback(_: &mut State, _: &ArgMatches) {}\n\npub fn pending(state: &mut State, args: &ArgMatches) {\n    let pending = state.pending_get();\n\n    if let Some(commit_number) = args\n        .get_one::<String>(\"COMMIT\")\n        .map_or(None, |x| x.parse::<i32>().map_or(None, |x| Some(x)))\n    {\n        // display selected\n        if (commit_number < 0) || (commit_number >= pending.len() as i32) {\n            println!(\n                \"Invalid selection. Please select commit numbers in the range of (0-{})\",\n                pending.len() - 1\n            );\n            return;\n        }\n\n        let copy = state.current.clone();\n        let changes = pending[commit_number as usize].clone();\n        println!(\"before : {}\", copy.get_hash());\n\n        let mut inversed = copy.clone();\n        inversed.unapply_changes(changes.change.clone());\n        println!(\"inverse : {}\", inversed.get_hash());\n\n        let mut after = inversed.clone();\n        after.apply_changes(changes.change.clone());\n        println!(\"after : {}\", after.get_hash());\n\n        let mut a = after\n            .serialise()\n            .split(\"\\n\")\n            .map(|x| x.to_string())\n            .collect::<Vec<String>>();\n        let mut b = copy\n            .serialise()\n            .split(\"\\n\")\n            .map(|x| x.to_string())\n            .collect::<Vec<String>>();\n\n        a.sort();\n        b.sort();\n\n        // println!(\"{}\", utils::generate_tree(&copy));\n        // println!(\"{}\", utils::generate_tree(&after));\n        // println!(\"{}\", utils::generate_tree(&inversed));\n\n        for i in 0..a.len() {\n            let c = a[i].clone();\n            let d = b[i].clone();\n            if c != d {\n                println!(\"{c}\\n{d}\\n\\n\\n\\n\\n\");\n            }\n        }\n    } else {\n        // display all\n        for (index, c) in pending.iter().enumerate() {\n            println!(\"{index}. {}\", c.header());\n        }\n    }\n}\n"
,\n};\n\n#[derive(Debug, Clone)]\npub struct Commit {\n    pub id: Option<u32>,\n    pub message: String,\n    pub description: String,\n    pub change: Change,\n    pub timestamp: u64,\n\n    pub author: String,\n}\nimpl Commit {\n    pub fn header(&self) -> String {\n        // \"integrated backwards compatibility\" (2025-5-26 16:30) (affected : change.rs, content.rs, ...)\n\n        let mut file_names = vec![];\n        for (_, parent) in self.change.as_map().1 {\n            for (f, _) in parent {\n                file_names.push(f);\n            }\n        }\n\n        format!(\n            \"({}) \\\"{}\\\" (affected : {}{})\",\n            utils::into_human_readable(self.timestamp),\n            self.message,\n            file_names\n                .iter()\n                .take(5)\n                .map(|x| x.to_string())\n                .collect::<Vec<String>>()\n                .join(\", \"),\n            if file_names.len() > 5 { \", ...\" } else { \"\" }\n        )\n    }\n\n    pub fn serialise(&self) -> String {\n        format!(\n            \"= {} {} {:?} {:?} {}\\n{}\",\n            self.id\n                .map_or(\"LOCAL\".to_string(), |i| format!(\"{:06x}\", i).clone()),\n            self.timestamp,\n            urlencoding::encode(&self.message).to_string(),\n            urlencoding::encode(&self.description).to_string(),\n            self.author,\n            self.change.serialise_changes()\n        )\n    }\n\n    pub fn deserialise(s: String) -> Option<Commit> {\n        // = LOCAL 1747682692319414000 \"initial%20commit\" \"\" no_one\n\n        let lines = s.split(\"\\n\").collect::<Vec<&str>>();\n        if lines.len() < 2 {\n            // return None;\n        }\n\n        let metadata = lines[0].split(\" \").collect::<Vec<&str>>();\n        if metadata.len() != 6 {\n            // return None;\n        }\n\n        let [_, status, time, message, description, author] = *metadata.as_slice() else {\n            return None;\n        };\n\n        Some(Commit {\n            id: status.parse::<u32>().map_or(None, |t| Some(t)),\n            message: urlencoding::decode(&message[1..message.len() - 1].to_string())\n                .unwrap()\n                .to_string(),\n            description: urlencoding::decode(&description[1..description.len() - 1].to_string())\n                .unwrap()\n                .to_string(),\n            change: Change::deserialise_changes(lines[1..].join(\"\\n\")).unwrap_or(Change::empty()),\n            timestamp: time.parse::<u64>().unwrap_or(0),\n            author: author.to_string(),\n        })\n    }\n}\n\npub fn add(_: &mut State, args: &ArgMatches) {\n    let f = args\n        .get_many::<PathBuf>(\"FILE\")\n        .unwrap()\n        .map(|x| x.clone())\n        .collect::<Vec<PathBuf>>();\n\n    let mut result: HashSet<String> = HashSet::from_iter(\n        fs::read_to_string(\"./.relic/tracked\")\n            .unwrap()\n            .split(\"\\n\")\n            .filter(|x| !x.is_empty())\n            .map(|x| x.to_string())\n            .collect::<Vec<String>>(),\n    );\n    for p in f {\n        // TODO : path.join for this? or concatenating / works?\n        result.insert(format!(\n            \"{}{}\",\n            p.to_string_lossy().to_string(),\n            if !p.to_string_lossy().to_string().ends_with(\"/\") && p.is_dir() {\n                \"/\"\n            } else {\n                \"\"\n            }\n        ));\n    }\n    let _ = fs::write(\n        \"./.relic/tracked\",\n        result.drain().collect::<Vec<String>>().join(\"\\n\"),\n    );\n}\n\npub fn remove(s: &mut State, args: &ArgMatches) {\n    let f = args\n        .get_many::<PathBuf>(\"FILE\")\n        .unwrap()\n        .map(|x| x.clone())\n        .collect::<Vec<PathBuf>>();\n\n    let result: HashSet<String> = HashSet::from_iter(\n        fs::read_to_string(\"./.relic/tracked\")\n            .unwrap()\n            .split(\"\\n\")\n            .filter(|x| !x.is_empty())\n            .map(|x| PathBuf::from(\".\").join(x).to_string_lossy().to_string())\n            .collect::<Vec<String>>(),\n    );\n\n    // initialise removed_content\n    let mut removed_content = ContentSet {\n        files: HashSet::from_iter(\n            f.iter()\n                .filter(|x| !x.is_dir())\n                .map(|x| PathBuf::from(\".\").join(x).to_string_lossy().to_string()),\n        ),\n        directories: HashSet::from_iter(\n            f.iter()\n                .filter(|x| x.is_dir())\n                .map(|x| PathBuf::from(\".\").join(x).to_string_lossy().to_string()),\n        ),\n    }\n    .initialise(&mut s.current);\n\n    let mut to_subtract: HashSet<String> = HashSet::from_iter(\n        removed_content\n            .directories\n            .drain()\n            .collect::<Vec<String>>()\n            .into_iter()\n            .map(|x| format!(\"{x}/\"))\n            .collect::<Vec<String>>(),\n    );\n    to_subtract = to_subtract\n        .union(&HashSet::from_iter(removed_content.files.drain()))\n        .map(|x| x.to_string())\n        .collect::<HashSet<String>>();\n\n    // set operations\n    // right join\n    // result - removed_content\n\n    let _ = fs::write(\n        \"./.relic/tracked\",\n        result\n            .difference(&to_subtract)\n            .map(|x| x[2..].to_string())\n            .collect::<Vec<String>>()\n            .join(\"\\n\"),\n    );\n}\n\npub fn commit(state: &mut State, args: &ArgMatches) {\n    // push into pending stage\n    // update upstream\n\n    // everything after the first line will be generated by Change::serialise_change\n    r#\"= {commit id} {unix timestamp of commit} {message} {description} {author}\n+ D \"lorem/ipsum/dolor\"\n+ F \"lorem/ipsum/dolor/earth.txt\" \"earth.txt\"\n- D \"lorem/sit\"\n=\n| \"lorem/ipsum/dolor/earth.txt\"\n+ 3 asdfsdf\n+ 5 sfsdf\n- 7\n| \"lorem/ipsum/saturn/txt\"\n+ 4 lsdfljs\"#;\n    let message = args.get_one::<String>(\"message\").unwrap().clone();\n    let description = args\n        .get_one::<String>(\"description\")\n        .map_or(\"\".to_string(), String::clone);\n\n    let commit = Commit {\n        id: None,\n        message,\n        description,\n        change: state.get_changes(),\n        timestamp: utils::get_time(),\n        author: \"no_one\".to_string(),\n    };\n\n    state.pending_add(commit);\n    // update upstream\n    (*state).update_upstream(&mut state.track_set.clone());\n}\n\npub fn push(_: &mut State, _: &ArgMatches) {}\n\npub fn pull(_: &mut State, _: &ArgMatches) {}\n\npub fn fetch(_: &mut State, _: &ArgMatches) {}\n\npub fn cherry(_: &mut State, _: &ArgMatches) {}\n\npub fn rollback(_: &mut State, _: &ArgMatches) {}\n\npub fn pending(state: &mut State, args: &ArgMatches) {\n    let pending = state.pending_get();\n\n    if let Some(commit_number) = args\n        .get_one::<String>(\"COMMIT\")\n        .map_or(None, |x| x.parse::<i32>().map_or(None, |x| Some(x)))\n    {\n        // display selected\n        if (commit_number < 0) || (commit_number >= pending.len() as i32) {\n            println!(\n                \"Invalid selection. Please select commit numbers in the range of (0-{})\",\n                pending.len() - 1\n            );\n            return;\n        }\n\n        let copy = state.current.clone();\n        let changes = pending[commit_number as usize].clone();\n        println!(\"before : {}\", copy.get_hash());\n\n        let mut after = copy.clone();\n        after.apply_changes(changes.change.clone());\n        println!(\"after : {}\", after.get_hash());\n\n        let mut inversed = after.clone();\n        inversed.unapply_changes(changes.change.clone());\n        println!(\"inverse : {}\", inversed.get_hash());\n\n        let mut a = inversed\n            .serialise()\n            .split(\"\\n\")\n            .map(|x| x.to_string())\n            .collect::<Vec<String>>();\n        let mut b = copy\n            .serialise()\n            .split(\"\\n\")\n            .map(|x| x.to_string())\n            .collect::<Vec<String>>();\n\n        a.sort();\n        b.sort();\n\n        // println!(\"{}\", utils::generate_tree(&copy));\n        // println!(\"{}\", utils::generate_tree(&after));\n        // println!(\"{}\", utils::generate_tree(&inversed));\n\n        for i in 0..a.len() {\n            let c = a[i].clone();\n            let d = b[i].clone();\n            if c != d {\n                println!(\"{c}\\n{d}\\n\\n\\n\\n\\n\");\n            }\n        }\n        // display all\n        for (index, c) in pending.iter().enumerate() {\n            println!(\"{index}. {}\", c.header());\n        }\n    }\n}\n"

= LOCAL 1748407882921 "whatever" "" no_one
=
| . Cargo.lock
- 2 "version = 3"
+ 2 "version = 4"
+ 20 "name = \"android-tzdata\""
+ 21 "version = \"0.1.1\""
+ 22 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 23 "checksum = \"e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0\""
+ 24 ""
+ 25 "[[package]]"
+ 26 "name = \"android_system_properties\""
+ 27 "version = \"0.1.5\""
+ 28 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 29 "checksum = \"819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311\""
+ 30 "dependencies = ["
+ 31 " \"libc\","
+ 32 "]"
+ 33 ""
+ 34 "[[package]]"
+ 96 "name = \"autocfg\""
+ 97 "version = \"1.4.0\""
+ 98 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 99 "checksum = \"ace50bade8e6234aa140d9a2f552bbee1db4d353f69b8217bc503490fc1a9f26\""
+ 100 ""
+ 101 "[[package]]"
+ 126 "name = \"bumpalo\""
+ 127 "version = \"3.17.0\""
+ 128 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 129 "checksum = \"1628fb46dfa0b37568d12e5edd512553eccf6a22a78e8bde00bb4aed84d5bdbf\""
+ 130 ""
+ 131 "[[package]]"
+ 138 "name = \"cc\""
+ 139 "version = \"1.2.24\""
+ 140 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 141 "checksum = \"16595d3be041c03b09d08d0858631facccee9221e579704070e6e9e4915d3bc7\""
+ 142 "dependencies = ["
+ 143 " \"shlex\","
+ 144 "]"
+ 145 ""
+ 146 "[[package]]"
+ 153 "name = \"chrono\""
+ 154 "version = \"0.4.41\""
+ 155 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 156 "checksum = \"c469d952047f47f91b68d1cba3f10d63c11d73e4636f24f08daf0278abf01c4d\""
+ 157 "dependencies = ["
+ 158 " \"android-tzdata\","
+ 159 " \"iana-time-zone\","
+ 160 " \"js-sys\","
+ 161 " \"num-traits\","
+ 162 " \"wasm-bindgen\","
+ 163 " \"windows-link\","
+ 164 "]"
+ 165 ""
+ 166 "[[package]]"
+ 200 "name = \"core-foundation-sys\""
+ 201 "version = \"0.8.7\""
+ 202 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 203 "checksum = \"773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b\""
+ 204 ""
+ 205 "[[package]]"
+ 269 "name = \"iana-time-zone\""
+ 270 "version = \"0.1.63\""
+ 271 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 272 "checksum = \"b0c919e5debc312ad217002b8048a17b7d83f80703865bbfcfebb0458b0b27d8\""
+ 273 "dependencies = ["
+ 274 " \"android_system_properties\","
+ 275 " \"core-foundation-sys\","
+ 276 " \"iana-time-zone-haiku\","
+ 277 " \"js-sys\","
+ 278 " \"log\","
+ 279 " \"wasm-bindgen\","
+ 280 " \"windows-core\","
+ 281 "]"
+ 282 ""
+ 283 "[[package]]"
+ 284 "name = \"iana-time-zone-haiku\""
+ 285 "version = \"0.1.2\""
+ 286 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 287 "checksum = \"f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f\""
+ 288 "dependencies = ["
+ 289 " \"cc\","
+ 290 "]"
+ 291 ""
+ 292 "[[package]]"
+ 305 "name = \"js-sys\""
+ 306 "version = \"0.3.77\""
+ 307 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 308 "checksum = \"1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f\""
+ 309 "dependencies = ["
+ 310 " \"once_cell\","
+ 311 " \"wasm-bindgen\","
+ 312 "]"
+ 313 ""
+ 314 "[[package]]"
+ 321 "name = \"log\""
+ 322 "version = \"0.4.27\""
+ 323 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 324 "checksum = \"13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94\""
+ 325 ""
+ 326 "[[package]]"
+ 342 "name = \"num-traits\""
+ 343 "version = \"0.2.19\""
+ 344 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 345 "checksum = \"071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841\""
+ 346 "dependencies = ["
+ 347 " \"autocfg\","
+ 348 "]"
+ 349 ""
+ 350 "[[package]]"
+ 393 " \"chrono\","
+ 402 " \"unescape\","
+ 481 "name = \"shlex\""
+ 482 "version = \"1.3.0\""
+ 483 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 484 "checksum = \"0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64\""
+ 485 ""
+ 486 "[[package]]"
+ 546 "name = \"unescape\""
+ 547 "version = \"0.1.0\""
+ 548 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 549 "checksum = \"ccb97dac3243214f8d8507998906ca3e2e0b900bf9bf4870477f125b82e68f6e\""
+ 550 ""
+ 551 "[[package]]"
+ 576 "name = \"wasm-bindgen\""
+ 577 "version = \"0.2.100\""
+ 578 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 579 "checksum = \"1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5\""
+ 580 "dependencies = ["
+ 581 " \"cfg-if\","
+ 582 " \"once_cell\","
+ 583 " \"rustversion\","
+ 584 " \"wasm-bindgen-macro\","
+ 585 "]"
+ 586 ""
+ 587 "[[package]]"
+ 588 "name = \"wasm-bindgen-backend\""
+ 589 "version = \"0.2.100\""
+ 590 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 591 "checksum = \"2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6\""
+ 592 "dependencies = ["
+ 593 " \"bumpalo\","
+ 594 " \"log\","
+ 595 " \"proc-macro2\","
+ 596 " \"quote\","
+ 597 " \"syn\","
+ 598 " \"wasm-bindgen-shared\","
+ 599 "]"
+ 600 ""
+ 601 "[[package]]"
+ 602 "name = \"wasm-bindgen-macro\""
+ 603 "version = \"0.2.100\""
+ 604 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 605 "checksum = \"7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407\""
+ 606 "dependencies = ["
+ 607 " \"quote\","
+ 608 " \"wasm-bindgen-macro-support\","
+ 609 "]"
+ 610 ""
+ 611 "[[package]]"
+ 612 "name = \"wasm-bindgen-macro-support\""
+ 613 "version = \"0.2.100\""
+ 614 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 615 "checksum = \"8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de\""
+ 616 "dependencies = ["
+ 617 " \"proc-macro2\","
+ 618 " \"quote\","
+ 619 " \"syn\","
+ 620 " \"wasm-bindgen-backend\","
+ 621 " \"wasm-bindgen-shared\","
+ 622 "]"
+ 623 ""
+ 624 "[[package]]"
+ 625 "name = \"wasm-bindgen-shared\""
+ 626 "version = \"0.2.100\""
+ 627 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 628 "checksum = \"1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d\""
+ 629 "dependencies = ["
+ 630 " \"unicode-ident\","
+ 631 "]"
+ 632 ""
+ 633 "[[package]]"
+ 634 "name = \"windows-core\""
+ 635 "version = \"0.61.2\""
+ 636 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 637 "checksum = \"c0fdd3ddb90610c7638aa2b3a3ab2904fb9e5cdbecc643ddb3647212781c4ae3\""
+ 638 "dependencies = ["
+ 639 " \"windows-implement\","
+ 640 " \"windows-interface\","
+ 641 " \"windows-link\","
+ 642 " \"windows-result\","
+ 643 " \"windows-strings\","
+ 644 "]"
+ 645 ""
+ 646 "[[package]]"
+ 647 "name = \"windows-implement\""
+ 648 "version = \"0.60.0\""
+ 649 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 650 "checksum = \"a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836\""
+ 651 "dependencies = ["
+ 652 " \"proc-macro2\","
+ 653 " \"quote\","
+ 654 " \"syn\","
+ 655 "]"
+ 656 ""
+ 657 "[[package]]"
+ 658 "name = \"windows-interface\""
+ 659 "version = \"0.59.1\""
+ 660 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 661 "checksum = \"bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8\""
+ 662 "dependencies = ["
+ 663 " \"proc-macro2\","
+ 664 " \"quote\","
+ 665 " \"syn\","
+ 666 "]"
+ 667 ""
+ 668 "[[package]]"
+ 669 "name = \"windows-link\""
+ 670 "version = \"0.1.1\""
+ 671 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 672 "checksum = \"76840935b766e1b0a05c0066835fb9ec80071d4c09a16f6bd5f7e655e3c14c38\""
+ 673 ""
+ 674 "[[package]]"
+ 675 "name = \"windows-result\""
+ 676 "version = \"0.3.4\""
+ 677 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 678 "checksum = \"56f42bd332cc6c8eac5af113fc0c1fd6a8fd2aa08a0119358686e5160d0586c6\""
+ 679 "dependencies = ["
+ 680 " \"windows-link\","
+ 681 "]"
+ 682 ""
+ 683 "[[package]]"
+ 684 "name = \"windows-strings\""
+ 685 "version = \"0.4.2\""
+ 686 "source = \"registry+https://github.com/rust-lang/crates.io-index\""
+ 687 "checksum = \"56e6c93f3a0c3b36176cb1327a4958a0353d5d166c2a35cb268ace15e91d3b57\""
+ 688 "dependencies = ["
+ 689 " \"windows-link\","
+ 690 "]"
+ 691 ""
+ 692 "[[package]]"
| . ipsum
- 0 "ichi"
- 1 "ni"
- 2 "san"
- 3 "shi"
- 4 "go"
- 5 "roku"
- 6 "nana"
+ 0 ",\\n};\\n\\n#[derive(Debug, Clone)]\\npub struct Commit {\\n    pub id: Option<u32>,\\n    pub message: String,\\n    pub description: String,\\n    pub change: Change,\\n    pub timestamp: u64,\\n\\n    pub author: String,\\n}\\nimpl Commit {\\n    pub fn header(&self) -> String {\\n        // \\\"integrated backwards compatibility\\\" (2025-5-26 16:30) (affected : change.rs, content.rs, ...)\\n\\n        let mut file_names = vec![];\\n        for (_, parent) in self.change.as_map().1 {\\n            for (f, _) in parent {\\n                file_names.push(f);\\n            }\\n        }\\n\\n        format!(\\n            \\\"({}) \\\\\\\"{}\\\\\\\" (affected : {}{})\\\",\\n            utils::into_human_readable(self.timestamp),\\n            self.message,\\n            file_names\\n                .iter()\\n                .take(5)\\n                .map(|x| x.to_string())\\n                .collect::<Vec<String>>()\\n                .join(\\\", \\\"),\\n            if file_names.len() > 5 { \\\", ...\\\" } else { \\\"\\\" }\\n        )\\n    }\\n\\n    pub fn serialise(&self) -> String {\\n        format!(\\n            \\\"= {} {} {:?} {:?} {}\\\\n{}\\\",\\n            self.id\\n                .map_or(\\\"LOCAL\\\".to_string(), |i| format!(\\\"{:06x}\\\", i).clone()),\\n            self.timestamp,\\n            urlencoding::encode(&self.message).to_string(),\\n            urlencoding::encode(&self.description).to_string(),\\n            self.author,\\n            self.change.serialise_changes()\\n        )\\n    }\\n\\n    pub fn deserialise(s: String) -> Option<Commit> {\\n        // = LOCAL 1747682692319414000 \\\"initial%20commit\\\" \\\"\\\" no_one\\n\\n        let lines = s.split(\\\"\\\\n\\\").collect::<Vec<&str>>();\\n        if lines.len() < 2 {\\n            // return None;\\n        }\\n\\n        let metadata = lines[0].split(\\\" \\\").collect::<Vec<&str>>();\\n        if metadata.len() != 6 {\\n            // return None;\\n        }\\n\\n        let [_, status, time, message, description, author] = *metadata.as_slice() else {\\n            return None;\\n        };\\n\\n        Some(Commit {\\n            id: status.parse::<u32>().map_or(None, |t| Some(t)),\\n            message: urlencoding::decode(&message[1..message.len() - 1].to_string())\\n                .unwrap()\\n                .to_string(),\\n            description: urlencoding::decode(&description[1..description.len() - 1].to_string())\\n                .unwrap()\\n                .to_string(),\\n            change: Change::deserialise_changes(lines[1..].join(\\\"\\\\n\\\")).unwrap_or(Change::empty()),\\n            timestamp: time.parse::<u64>().unwrap_or(0),\\n            author: author.to_string(),\\n        })\\n    }\\n}\\n\\npub fn add(_: &mut State, args: &ArgMatches) {\\n    let f = args\\n        .get_many::<PathBuf>(\\\"FILE\\\")\\n        .unwrap()\\n        .map(|x| x.clone())\\n        .collect::<Vec<PathBuf>>();\\n\\n    let mut result: HashSet<String> = HashSet::from_iter(\\n        fs::read_to_string(\\\"./.relic/tracked\\\")\\n            .unwrap()\\n            .split(\\\"\\\\n\\\")\\n            .filter(|x| !x.is_empty())\\n            .map(|x| x.to_string())\\n            .collect::<Vec<String>>(),\\n    );\\n    for p in f {\\n        // TODO : path.join for this? or concatenating / works?\\n        result.insert(format!(\\n            \\\"{}{}\\\",\\n            p.to_string_lossy().to_string(),\\n            if !p.to_string_lossy().to_string().ends_with(\\\"/\\\") && p.is_dir() {\\n                \\\"/\\\"\\n            } else {\\n                \\\"\\\"\\n            }\\n        ));\\n    }\\n    let _ = fs::write(\\n        \\\"./.relic/tracked\\\",\\n        result.drain().collect::<Vec<String>>().join(\\\"\\\\n\\\"),\\n    );\\n}\\n\\npub fn remove(s: &mut State, args: &ArgMatches) {\\n    let f = args\\n        .get_many::<PathBuf>(\\\"FILE\\\")\\n        .unwrap()\\n        .map(|x| x.clone())\\n        .collect::<Vec<PathBuf>>();\\n\\n    let result: HashSet<String> = HashSet::from_iter(\\n        fs::read_to_string(\\\"./.relic/tracked\\\")\\n            .unwrap()\\n            .split(\\\"\\\\n\\\")\\n            .filter(|x| !x.is_empty())\\n            .map(|x| PathBuf::from(\\\".\\\").join(x).to_string_lossy().to_string())\\n            .collect::<Vec<String>>(),\\n    );\\n\\n    // initialise removed_content\\n    let mut removed_content = ContentSet {\\n        files: HashSet::from_iter(\\n            f.iter()\\n                .filter(|x| !x.is_dir())\\n                .map(|x| PathBuf::from(\\\".\\\").join(x).to_string_lossy().to_string()),\\n        ),\\n        directories: HashSet::from_iter(\\n            f.iter()\\n                .filter(|x| x.is_dir())\\n                .map(|x| PathBuf::from(\\\".\\\").join(x).to_string_lossy().to_string()),\\n        ),\\n    }\\n    .initialise(&mut s.current);\\n\\n    let mut to_subtract: HashSet<String> = HashSet::from_iter(\\n        removed_content\\n            .directories\\n            .drain()\\n            .collect::<Vec<String>>()\\n            .into_iter()\\n            .map(|x| format!(\\\"{x}/\\\"))\\n            .collect::<Vec<String>>(),\\n    );\\n    to_subtract = to_subtract\\n        .union(&HashSet::from_iter(removed_content.files.drain()))\\n        .map(|x| x.to_string())\\n        .collect::<HashSet<String>>();\\n\\n    // set operations\\n    // right join\\n    // result - removed_content\\n\\n    let _ = fs::write(\\n        \\\"./.relic/tracked\\\",\\n        result\\n            .difference(&to_subtract)\\n            .map(|x| x[2..].to_string())\\n            .collect::<Vec<String>>()\\n            .join(\\\"\\\\n\\\"),\\n    );\\n}\\n\\npub fn commit(state: &mut State, args: &ArgMatches) {\\n    // push into pending stage\\n    // update upstream\\n\\n    // everything after the first line will be generated by Change::serialise_change\\n    r#\\\"= {commit id} {unix timestamp of commit} {message} {description} {author}\\n+ D \\\"lorem/ipsum/dolor\\\"\\n+ F \\\"lorem/ipsum/dolor/earth.txt\\\" \\\"earth.txt\\\"\\n- D \\\"lorem/sit\\\"\\n=\\n| \\\"lorem/ipsum/dolor/earth.txt\\\"\\n+ 3 asdfsdf\\n+ 5 sfsdf\\n- 7\\n| \\\"lorem/ipsum/saturn/txt\\\"\\n+ 4 lsdfljs\\\"#;\\n    let message = args.get_one::<String>(\\\"message\\\").unwrap().clone();\\n    let description = args\\n        .get_one::<String>(\\\"description\\\")\\n        .map_or(\\\"\\\".to_string(), String::clone);\\n\\n    let commit = Commit {\\n        id: None,\\n        message,\\n        description,\\n        change: state.get_changes(),\\n        timestamp: utils::get_time(),\\n        author: \\\"no_one\\\".to_string(),\\n    };\\n\\n    state.pending_add(commit);\\n    // update upstream\\n    (*state).update_upstream(&mut state.track_set.clone());\\n}\\n\\npub fn push(_: &mut State, _: &ArgMatches) {}\\n\\npub fn pull(_: &mut State, _: &ArgMatches) {}\\n\\npub fn fetch(_: &mut State, _: &ArgMatches) {}\\n\\npub fn cherry(_: &mut State, _: &ArgMatches) {}\\n\\npub fn rollback(_: &mut State, _: &ArgMatches) {}\\n\\npub fn pending(state: &mut State, args: &ArgMatches) {\\n    let pending = state.pending_get();\\n\\n    if let Some(commit_number) = args\\n        .get_one::<String>(\\\"COMMIT\\\")\\n        .map_or(None, |x| x.parse::<i32>().map_or(None, |x| Some(x)))\\n    {\\n        // display selected\\n        if (commit_number < 0) || (commit_number >= pending.len() as i32) {\\n            println!(\\n                \\\"Invalid selection. Please select commit numbers in the range of (0-{})\\\",\\n                pending.len() - 1\\n            );\\n            return;\\n        }\\n\\n        let copy = state.current.clone();\\n        let changes = pending[commit_number as usize].clone();\\n        println!(\\\"before : {}\\\", copy.get_hash());\\n\\n        let mut inversed = copy.clone();\\n        inversed.unapply_changes(changes.change.clone());\\n        println!(\\\"inverse : {}\\\", inversed.get_hash());\\n\\n        let mut after = inversed.clone();\\n        after.apply_changes(changes.change.clone());\\n        println!(\\\"after : {}\\\", after.get_hash());\\n\\n        let mut a = after\\n            .serialise()\\n            .split(\\\"\\\\n\\\")\\n            .map(|x| x.to_string())\\n            .collect::<Vec<String>>();\\n        let mut b = copy\\n            .serialise()\\n            .split(\\\"\\\\n\\\")\\n            .map(|x| x.to_string())\\n            .collect::<Vec<String>>();\\n\\n        a.sort();\\n        b.sort();\\n\\n        // println!(\\\"{}\\\", utils::generate_tree(&copy));\\n        // println!(\\\"{}\\\", utils::generate_tree(&after));\\n        // println!(\\\"{}\\\", utils::generate_tree(&inversed));\\n\\n        for i in 0..a.len() {\\n            let c = a[i].clone();\\n            let d = b[i].clone();\\n            if c != d {\\n                println!(\\\"{c}\\\\n{d}\\\\n\\\\n\\\\n\\\\n\\\\n\\\");\\n            }\\n        }\\n    } else {\\n        // display all\\n        for (index, c) in pending.iter().enumerate() {\\n            println!(\\\"{index}. {}\\\", c.header());\\n        }\\n    }\\n}\\n\""
+ 1 ",\\n};\\n\\n#[derive(Debug, Clone)]\\npub struct Commit {\\n    pub id: Option<u32>,\\n    pub message: String,\\n    pub description: String,\\n    pub change: Change,\\n    pub timestamp: u64,\\n\\n    pub author: String,\\n}\\nimpl Commit {\\n    pub fn header(&self) -> String {\\n        // \\\"integrated backwards compatibility\\\" (2025-5-26 16:30) (affected : change.rs, content.rs, ...)\\n\\n        let mut file_names = vec![];\\n        for (_, parent) in self.change.as_map().1 {\\n            for (f, _) in parent {\\n                file_names.push(f);\\n            }\\n        }\\n\\n        format!(\\n            \\\"({}) \\\\\\\"{}\\\\\\\" (affected : {}{})\\\",\\n            utils::into_human_readable(self.timestamp),\\n            self.message,\\n            file_names\\n                .iter()\\n                .take(5)\\n                .map(|x| x.to_string())\\n                .collect::<Vec<String>>()\\n                .join(\\\", \\\"),\\n            if file_names.len() > 5 { \\\", ...\\\" } else { \\\"\\\" }\\n        )\\n    }\\n\\n    pub fn serialise(&self) -> String {\\n        format!(\\n            \\\"= {} {} {:?} {:?} {}\\\\n{}\\\",\\n            self.id\\n                .map_or(\\\"LOCAL\\\".to_string(), |i| format!(\\\"{:06x}\\\", i).clone()),\\n            self.timestamp,\\n            urlencoding::encode(&self.message).to_string(),\\n            urlencoding::encode(&self.description).to_string(),\\n            self.author,\\n            self.change.serialise_changes()\\n        )\\n    }\\n\\n    pub fn deserialise(s: String) -> Option<Commit> {\\n        // = LOCAL 1747682692319414000 \\\"initial%20commit\\\" \\\"\\\" no_one\\n\\n        let lines = s.split(\\\"\\\\n\\\").collect::<Vec<&str>>();\\n        if lines.len() < 2 {\\n            // return None;\\n        }\\n\\n        let metadata = lines[0].split(\\\" \\\").collect::<Vec<&str>>();\\n        if metadata.len() != 6 {\\n            // return None;\\n        }\\n\\n        let [_, status, time, message, description, author] = *metadata.as_slice() else {\\n            return None;\\n        };\\n\\n        Some(Commit {\\n            id: status.parse::<u32>().map_or(None, |t| Some(t)),\\n            message: urlencoding::decode(&message[1..message.len() - 1].to_string())\\n                .unwrap()\\n                .to_string(),\\n            description: urlencoding::decode(&description[1..description.len() - 1].to_string())\\n                .unwrap()\\n                .to_string(),\\n            change: Change::deserialise_changes(lines[1..].join(\\\"\\\\n\\\")).unwrap_or(Change::empty()),\\n            timestamp: time.parse::<u64>().unwrap_or(0),\\n            author: author.to_string(),\\n        })\\n    }\\n}\\n\\npub fn add(_: &mut State, args: &ArgMatches) {\\n    let f = args\\n        .get_many::<PathBuf>(\\\"FILE\\\")\\n        .unwrap()\\n        .map(|x| x.clone())\\n        .collect::<Vec<PathBuf>>();\\n\\n    let mut result: HashSet<String> = HashSet::from_iter(\\n        fs::read_to_string(\\\"./.relic/tracked\\\")\\n            .unwrap()\\n            .split(\\\"\\\\n\\\")\\n            .filter(|x| !x.is_empty())\\n            .map(|x| x.to_string())\\n            .collect::<Vec<String>>(),\\n    );\\n    for p in f {\\n        // TODO : path.join for this? or concatenating / works?\\n        result.insert(format!(\\n            \\\"{}{}\\\",\\n            p.to_string_lossy().to_string(),\\n            if !p.to_string_lossy().to_string().ends_with(\\\"/\\\") && p.is_dir() {\\n                \\\"/\\\"\\n            } else {\\n                \\\"\\\"\\n            }\\n        ));\\n    }\\n    let _ = fs::write(\\n        \\\"./.relic/tracked\\\",\\n        result.drain().collect::<Vec<String>>().join(\\\"\\\\n\\\"),\\n    );\\n}\\n\\npub fn remove(s: &mut State, args: &ArgMatches) {\\n    let f = args\\n        .get_many::<PathBuf>(\\\"FILE\\\")\\n        .unwrap()\\n        .map(|x| x.clone())\\n        .collect::<Vec<PathBuf>>();\\n\\n    let result: HashSet<String> = HashSet::from_iter(\\n        fs::read_to_string(\\\"./.relic/tracked\\\")\\n            .unwrap()\\n            .split(\\\"\\\\n\\\")\\n            .filter(|x| !x.is_empty())\\n            .map(|x| PathBuf::from(\\\".\\\").join(x).to_string_lossy().to_string())\\n            .collect::<Vec<String>>(),\\n    );\\n\\n    // initialise removed_content\\n    let mut removed_content = ContentSet {\\n        files: HashSet::from_iter(\\n            f.iter()\\n                .filter(|x| !x.is_dir())\\n                .map(|x| PathBuf::from(\\\".\\\").join(x).to_string_lossy().to_string()),\\n        ),\\n        directories: HashSet::from_iter(\\n            f.iter()\\n                .filter(|x| x.is_dir())\\n                .map(|x| PathBuf::from(\\\".\\\").join(x).to_string_lossy().to_string()),\\n        ),\\n    }\\n    .initialise(&mut s.current);\\n\\n    let mut to_subtract: HashSet<String> = HashSet::from_iter(\\n        removed_content\\n            .directories\\n            .drain()\\n            .collect::<Vec<String>>()\\n            .into_iter()\\n            .map(|x| format!(\\\"{x}/\\\"))\\n            .collect::<Vec<String>>(),\\n    );\\n    to_subtract = to_subtract\\n        .union(&HashSet::from_iter(removed_content.files.drain()))\\n        .map(|x| x.to_string())\\n        .collect::<HashSet<String>>();\\n\\n    // set operations\\n    // right join\\n    // result - removed_content\\n\\n    let _ = fs::write(\\n        \\\"./.relic/tracked\\\",\\n        result\\n            .difference(&to_subtract)\\n            .map(|x| x[2..].to_string())\\n            .collect::<Vec<String>>()\\n            .join(\\\"\\\\n\\\"),\\n    );\\n}\\n\\npub fn commit(state: &mut State, args: &ArgMatches) {\\n    // push into pending stage\\n    // update upstream\\n\\n    // everything after the first line will be generated by Change::serialise_change\\n    r#\\\"= {commit id} {unix timestamp of commit} {message} {description} {author}\\n+ D \\\"lorem/ipsum/dolor\\\"\\n+ F \\\"lorem/ipsum/dolor/earth.txt\\\" \\\"earth.txt\\\"\\n- D \\\"lorem/sit\\\"\\n=\\n| \\\"lorem/ipsum/dolor/earth.txt\\\"\\n+ 3 asdfsdf\\n+ 5 sfsdf\\n- 7\\n| \\\"lorem/ipsum/saturn/txt\\\"\\n+ 4 lsdfljs\\\"#;\\n    let message = args.get_one::<String>(\\\"message\\\").unwrap().clone();\\n    let description = args\\n        .get_one::<String>(\\\"description\\\")\\n        .map_or(\\\"\\\".to_string(), String::clone);\\n\\n    let commit = Commit {\\n        id: None,\\n        message,\\n        description,\\n        change: state.get_changes(),\\n        timestamp: utils::get_time(),\\n        author: \\\"no_one\\\".to_string(),\\n    };\\n\\n    state.pending_add(commit);\\n    // update upstream\\n    (*state).update_upstream(&mut state.track_set.clone());\\n}\\n\\npub fn push(_: &mut State, _: &ArgMatches) {}\\n\\npub fn pull(_: &mut State, _: &ArgMatches) {}\\n\\npub fn fetch(_: &mut State, _: &ArgMatches) {}\\n\\npub fn cherry(_: &mut State, _: &ArgMatches) {}\\n\\npub fn rollback(_: &mut State, _: &ArgMatches) {}\\n\\npub fn pending(state: &mut State, args: &ArgMatches) {\\n    let pending = state.pending_get();\\n\\n    if let Some(commit_number) = args\\n        .get_one::<String>(\\\"COMMIT\\\")\\n        .map_or(None, |x| x.parse::<i32>().map_or(None, |x| Some(x)))\\n    {\\n        // display selected\\n        if (commit_number < 0) || (commit_number >= pending.len() as i32) {\\n            println!(\\n                \\\"Invalid selection. Please select commit numbers in the range of (0-{})\\\",\\n                pending.len() - 1\\n            );\\n            return;\\n        }\\n\\n        let copy = state.current.clone();\\n        let changes = pending[commit_number as usize].clone();\\n        println!(\\\"before : {}\\\", copy.get_hash());\\n\\n        let mut after = copy.clone();\\n        after.apply_changes(changes.change.clone());\\n        println!(\\\"after : {}\\\", after.get_hash());\\n\\n        let mut inversed = after.clone();\\n        inversed.unapply_changes(changes.change.clone());\\n        println!(\\\"inverse : {}\\\", inversed.get_hash());\\n\\n        let mut a = inversed\\n            .serialise()\\n            .split(\\\"\\\\n\\\")\\n            .map(|x| x.to_string())\\n            .collect::<Vec<String>>();\\n        let mut b = copy\\n            .serialise()\\n            .split(\\\"\\\\n\\\")\\n            .map(|x| x.to_string())\\n            .collect::<Vec<String>>();\\n\\n        a.sort();\\n        b.sort();\\n\\n        // println!(\\\"{}\\\", utils::generate_tree(&copy));\\n        // println!(\\\"{}\\\", utils::generate_tree(&after));\\n        // println!(\\\"{}\\\", utils::generate_tree(&inversed));\\n\\n        for i in 0..a.len() {\\n            let c = a[i].clone();\\n            let d = b[i].clone();\\n            if c != d {\\n                println!(\\\"{c}\\\\n{d}\\\\n\\\\n\\\\n\\\\n\\\\n\\\");\\n            }\\n        }\\n        // display all\\n        for (index, c) in pending.iter().enumerate() {\\n            println!(\\\"{index}. {}\\\", c.header());\\n        }\\n    }\\n}\\n\""
+ 2 ""
| .%2Fsrc change.rs
- 183 "                    if let Some((p, _)) = &previous_file {"
- 184 "                        if content.len() < 3 {"
- 185 "                            return None;"
- 186 "                        }"
- 187 "                    }"
- 188 ""
- 522 "        // let mut result ="
+ 516 "        // the order does not follow the optimised/intuitive format"
+ 517 "        // additions will appear before deletions if inversed"
+ 518 "        // but relic will always apply changes in the correct order regardless"
- 524 "        Change::empty()"
+ 520 "        Change {"
+ 521 "            container_modifications: self"
+ 522 "                .container_modifications"
+ 523 "                .iter()"
+ 524 "                .map(|c| match c {"
+ 525 "                    ContainerModification::CreateFile(p, n) => {"
+ 526 "                        ContainerModification::DeleteFile(p.to_string(), n.to_string())"
+ 527 "                    }"
+ 528 "                    ContainerModification::CreateDirectory(p, n) => {"
+ 529 "                        ContainerModification::DeleteDirectory(p.to_string(), n.to_string())"
+ 530 "                    }"
+ 531 "                    ContainerModification::DeleteFile(p, n) => {"
+ 532 "                        ContainerModification::CreateFile(p.to_string(), n.to_string())"
+ 533 "                    }"
+ 534 "                    ContainerModification::DeleteDirectory(p, n) => {"
+ 535 "                        ContainerModification::CreateDirectory(p.to_string(), n.to_string())"
+ 536 "                    }"
+ 537 "                })"
+ 538 "                .collect::<Vec<ContainerModification>>(),"
+ 539 "            modifications: self"
+ 540 "                .modifications"
+ 541 "                .iter()"
+ 542 "                .map(|m| match m {"
+ 543 "                    Modification::Create(p, f, l, t) => {"
+ 544 "                        Modification::Delete(p.to_string(), f.to_string(), *l, t.to_string())"
+ 545 "                    }"
+ 546 "                    Modification::Delete(p, f, l, t) => {"
+ 547 "                        Modification::Create(p.to_string(), f.to_string(), *l, t.to_string())"
+ 548 "                    }"
+ 549 "                })"
+ 550 "                .collect::<Vec<Modification>>(),"
+ 551 "        }"
| .%2Fsrc commit.rs
- 11 "#[derive(Debug)]"
+ 11 "#[derive(Debug, Clone)]"
| .%2Fsrc content.rs
+ 118 "    pub fn get_hash(&self) -> String {"
+ 119 "        sha256::digest(serde_json::to_string(&self).unwrap())"
+ 120 "    }"
+ 121 ""
- 241 "    pub fn unapply_changes(&mut self, changes: Change) {}"
+ 245 "    pub fn unapply_changes(&mut self, changes: Change) {"
+ 246 "        // TODO : test if 100% reliable"
+ 247 "        let changes = changes.inverse();"
+ 248 "        self.apply_changes(changes);"
+ 249 "    }"
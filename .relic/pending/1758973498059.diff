= LOCAL 1758973498059 "" "" no_one
+ F . .relic_ignore
- F .%2Florem mars
- F .%2Florem earth
+ F .%2Florem .relic_ignore
+ F .%2Florem earth%20copy
- F .%2Florem%2Fipsum saturn
- F .%2Florem%2Fipsum temp
+ F .%2Florem%2Fipsum saturn_new
+ F .%2Florem%2Fipsum%2Fdolor venus
+ F .%2Florem%2Fipsum%2Fdolor hm
=
| . .relic_ignore
+ 0 "-- Added by Relic: Automatically ignore all git content"
+ 1 ".git/"
+ 2 ".gitignore"
+ 4 "target/"
+ 5 "Cargo.lock"
| .%2Florem .relic_ignore
- 0 ""
+ 0 "-- Added by Relic: Automatically ignore all git content"
+ 1 ".git/"
+ 2 ".gitignore"
| .%2Florem earth%20copy
- 0 ""
+ 0 "can you understand me?"
+ 1 "kjadlfjlskdf"
+ 2 "ljs;kljflsdjl;kfsd"
| .%2Florem pluto
- 0 ""
+ 0 "ashjdfskdfjs"
+ 1 "lajjsflkjas;dfkjkasjdfklj'ashjdfskdfjs"
+ 2 "jas;ldfjlsajdf"
| .%2Florem%2Fipsum saturn_new
- 0 ""
+ 0 "lasjdklfsjaklfdjsklfjsklf"
+ 1 "akl;js;klfdjs;ldjfklsfd"
| .%2Florem%2Fipsum%2Fdolor venus
- 0 ""
+ 0 "al;kjdklfjsalfjsljfklljeowrpyuqiwfoid"
+ 1 "fqlkwoipdngayuowhqjpofqpnigewi"
+ 2 "alksdjflsjkld"
+ 3 "alsjdkfl;jsaklfjlkjiehqojek;dfk;"
+ 4 "jklajfdoihqodjkfs"
| .%2Fsrc utils.rs
- 0 "use std::time::{Duration, SystemTime, UNIX_EPOCH};"
+ 0 "use std::{"
+ 1 "    collections::{HashMap, HashSet},"
+ 2 "    path::PathBuf,"
+ 3 "    time::{Duration, SystemTime, UNIX_EPOCH},"
+ 4 "};"
- 4 "use crate::core::{Content, Tree};"
+ 8 "use crate::core::{modifications, Blob, Content, Tree};"
+ 9 ""
+ 10 "impl Blob {"
+ 11 "    pub fn get_blame_header("
+ 12 "        &self,"
+ 13 "        modifications: &HashMap<String, bool>,"
+ 14 "        blob_info: &Vec<modifications::Blob>,"
+ 15 "    ) -> String {"
+ 16 "        // returns:"
+ 17 "        // (-) earth"
+ 18 "        // (+) mars"
+ 19 "        // venus [+10, -10]"
+ 20 ""
+ 21 "        let mod_type: Option<bool> = modifications.get(&self.name).copied();"
+ 22 ""
+ 23 "        format!("
+ 24 "            \"{}{} {}\","
+ 25 "            match mod_type {"
+ 26 "                Some(m) => {"
+ 27 "                    if m {"
+ 28 "                        \"(+) \""
+ 29 "                    } else {"
+ 30 "                        \"(-) \""
+ 31 "                    }"
+ 32 "                }"
+ 33 "                None => \"\","
+ 34 "            },"
+ 35 "            self.name.clone(),"
+ 36 "            if blob_info.is_empty() {"
+ 37 "                \"\".to_string()"
+ 38 "            } else {"
+ 39 "                format!("
+ 40 "                    \"[+{}, -{}]\","
+ 41 "                    blob_info"
+ 42 "                        .iter()"
+ 43 "                        .filter(|b| match b {"
+ 44 "                            modifications::Blob::Create(_, _, _, _) => true,"
+ 45 "                            _ => false,"
+ 46 "                        })"
+ 47 "                        .count(),"
+ 48 "                    blob_info"
+ 49 "                        .iter()"
+ 50 "                        .filter(|b| match b {"
+ 51 "                            modifications::Blob::Delete(_, _, _, _) => true,"
+ 52 "                            _ => false,"
+ 53 "                        })"
+ 54 "                        .count(),"
+ 55 "                )"
+ 56 "            }"
+ 57 "        )"
+ 58 "    }"
+ 59 "}"
+ 60 ""
+ 61 "pub fn generate_blame_tree("
+ 62 "    tree: &Tree,"
+ 63 "    tree_map: &HashMap<String, HashSet<modifications::Tree>>,"
+ 64 "    blob_map: &HashMap<String, HashMap<String, Vec<modifications::Blob>>>,"
+ 65 ") -> String {"
+ 66 "    return generate_blame_subtree("
+ 67 "        &Content::Tree(tree.clone()),"
+ 68 "        PathBuf::from(\".\"),"
+ 69 "        tree_map,"
+ 70 "        blob_map,"
+ 71 "    );"
+ 72 "}"
+ 73 ""
+ 74 "pub fn generate_blame_subtree("
+ 75 "    c: &Content,"
+ 76 "    path: PathBuf,"
+ 77 "    tree_map: &HashMap<String, HashSet<modifications::Tree>>,"
+ 78 "    blob_map: &HashMap<String, HashMap<String, Vec<modifications::Blob>>>,"
+ 79 ") -> String {"
+ 80 "    let mut result = vec![];"
+ 81 ""
+ 82 "    let modifications ="
+ 83 "        tree_map"
+ 84 "            .get(&path.to_string_lossy().to_string())"
+ 85 "            .map_or(HashMap::new(), |h| {"
+ 86 "                h.into_iter()"
+ 87 "                    .map(|v| match v {"
+ 88 "                        modifications::Tree::CreateTree(_, n)"
+ 89 "                        | modifications::Tree::CreateBlob(_, n) => (n.to_string(), true),"
+ 90 "                        modifications::Tree::DeleteTree(_, n)"
+ 91 "                        | modifications::Tree::DeleteBlob(_, n) => (n.to_string(), false),"
+ 92 "                    })"
+ 93 "                    .collect::<HashMap<String, bool>>()"
+ 94 "            });"
+ 95 ""
+ 96 "    match c {"
+ 97 "        Content::Tree(t) => {"
+ 98 "            let name = t.name.clone();"
+ 99 "            let mut r = vec![name];"
+ 100 "            if t.content.len() >= 1 {"
+ 101 "                let length = t.content.len() - 1;"
+ 102 "                for (index, i) in t.content.iter().enumerate() {"
+ 103 "                    let mut p = path.clone();"
+ 104 "                    if !t.name.is_empty() {"
+ 105 "                        p = path.join(t.name.clone());"
+ 106 "                    }"
+ 107 "                    for (inner_index, line) in generate_blame_subtree(i, p, tree_map, blob_map)"
+ 108 "                        .split(\"\\n\")"
+ 109 "                        .enumerate()"
+ 110 "                    {"
+ 111 "                        r.push(format!("
+ 112 "                            \" {} {line}\","
+ 113 "                            if index == length {"
+ 114 "                                if inner_index == 0 {"
+ 115 "                                    \"└\""
+ 116 "                                } else {"
+ 117 "                                    \"\""
+ 118 "                                }"
+ 119 "                            } else {"
+ 120 "                                if inner_index == 0 {"
+ 121 "                                    \"├\""
+ 122 "                                } else {"
+ 123 "                                    \"│\""
+ 124 "                                }"
+ 125 "                            }"
+ 126 "                        ));"
+ 127 "                    }"
+ 128 "                }"
+ 129 "            }"
+ 130 "            result.push(r.join(\"\\n\"));"
+ 131 "        }"
+ 132 "        Content::Blob(b) => {"
+ 133 "            let blob_info = blob_map"
+ 134 "                .get(&path.to_string_lossy().to_string())"
+ 135 "                .map_or(vec![], |m| m.get(&b.name).unwrap_or(&vec![]).to_vec());"
+ 136 ""
+ 137 "            result.push(b.get_blame_header(&modifications, &blob_info));"
+ 138 "            // result.push(format!(\"{} ({})\", b.name, sha256::digest(&b.content)));"
+ 139 "        }"
+ 140 "    }"
+ 141 ""
+ 142 "    result.join(\"\\n\")"
+ 143 "}"
| .%2Fsrc%2Fcommands pending.rs
+ 20 "        // if want the blamed tree here, need to refer to previous upstream"
| .%2Fsrc%2Fcommands staging.rs
- 9 "            .serialise_changes()"
+ 9 "            .as_human_readable(&s.upstream)"
| .%2Fsrc%2Fcore commit.rs
- 18 "        let mut file_names = vec![];"
- 19 "        for (_, parent) in self.change.as_map().1 {"
- 20 "            for (f, _) in parent {"
- 21 "                file_names.push(f);"
- 22 "            }"
- 23 "        }"
+ 18 "        let file_names = self.change.get_affected_blobs();"
| .%2Fsrc%2Fcore state.rs
- 194 "        self.upstream.apply_changes(changes);"
+ 194 "        self.upstream.apply_changes(&changes);"
| .%2Fsrc%2Fcore%2Fobjects%2Fdata content.rs
+ 9 "impl Content {"
+ 10 "    pub fn get_name(&self) -> String {"
+ 11 "        match self {"
+ 12 "            Content::Tree(tree) => tree.name.clone(),"
+ 13 "            Content::Blob(blob) => blob.name.clone(),"
+ 14 "        }"
+ 15 "    }"
+ 16 "}"
| .%2Fsrc%2Fcore%2Fobjects%2Fdata tree.rs
- 53 "    pub fn apply_changes(&mut self, changes: Change) {"
+ 53 "    pub fn apply_changes(&mut self, changes: &Change) {"
- 163 "    pub fn unapply_changes(&mut self, changes: Change) {"
+ 163 "    pub fn unapply_changes(&mut self, changes: &Change) {"
- 166 "        self.apply_changes(changes);"
+ 166 "        self.apply_changes(&changes);"
| .%2Fsrc%2Fcore%2Fobjects%2Fmodifications%2Fchange mod.rs
- 5 "use std::collections::{HashMap, HashSet};"
+ 5 "use std::{"
+ 6 "    collections::{HashMap, HashSet},"
+ 7 "    thread::current,"
+ 8 "};"
- 9 "use crate::core::modifications;"
+ 12 "use crate::{"
+ 13 "    core::{content_set::ContentSet, modifications, State, Tree},"
+ 14 "    utils,"
+ 15 "};"
+ 30 "    pub fn get_affected_blobs(&self) -> Vec<String> {"
+ 31 "        let mut blobs = vec![];"
+ 32 "        for (_, parent) in self.as_map().1 {"
+ 33 "            blobs.append(&mut parent.iter().map(|f| f.0.to_string()).collect())"
+ 34 "        }"
+ 35 "        blobs"
+ 36 "    }"
+ 37 ""
+ 38 "    pub fn as_human_readable(&self, current_upstream: &Tree) -> String {"
+ 39 "        // HashMap<String, HashSet<modifications::Tree>>,"
+ 40 "        // HashMap<String, HashMap<String, Vec<modifications::Blob>>>,"
+ 41 ""
+ 42 "        let mut changes = self.clone();"
+ 43 "        changes.trees = changes"
+ 44 "            .trees"
+ 45 "            .clone()"
+ 46 "            .into_iter()"
+ 47 "            .filter(|t| match t {"
+ 48 "                modifications::Tree::DeleteBlob(_, _) | modifications::Tree::DeleteTree(_, _) => {"
+ 49 "                    false"
+ 50 "                }"
+ 51 "                _ => true,"
+ 52 "            })"
+ 53 "            .collect::<Vec<modifications::Tree>>();"
+ 54 ""
+ 55 "        let (tree_map, blob_map) = self.as_map();"
+ 56 ""
+ 57 "        let mut current_upstream = current_upstream.clone();"
+ 58 "        current_upstream.apply_changes(&changes);"
+ 59 ""
+ 60 "        /*"
+ 61 "            {full change}"
+ 62 ""
+ 63 "            repo_name"
+ 64 "             ├ (+) saturn"
+ 65 "             ├ (-) jupiter"
+ 66 "             └ huh/mod.rs [+11, -52]"
+ 67 ""
+ 68 "            x files affected, x additions, x deletions"
+ 69 "        */"
+ 70 ""
+ 71 "        let affected_files = blob_map"
+ 72 "            .iter()"
+ 73 "            .map(|(_, v)| v.keys().count())"
+ 74 "            .sum::<usize>();"
+ 75 ""
+ 76 "        let addition = blob_map"
+ 77 "            .iter()"
+ 78 "            .map(|(_, v)| {"
+ 79 "                v.iter()"
+ 80 "                    .map(|(_, b)| {"
+ 81 "                        b.iter()"
+ 82 "                            .filter(|i| match i {"
+ 83 "                                modifications::Blob::Create(_, _, _, _) => true,"
+ 84 "                                _ => false,"
+ 85 "                            })"
+ 86 "                            .count()"
+ 87 "                    })"
+ 88 "                    .sum::<usize>()"
+ 89 "            })"
+ 90 "            .sum::<usize>();"
+ 91 ""
+ 92 "        let deletion = blob_map"
+ 93 "            .iter()"
+ 94 "            .map(|(_, v)| {"
+ 95 "                v.iter()"
+ 96 "                    .map(|(_, b)| {"
+ 97 "                        b.iter()"
+ 98 "                            .filter(|i| match i {"
+ 99 "                                modifications::Blob::Delete(_, _, _, _) => true,"
+ 100 "                                _ => false,"
+ 101 "                            })"
+ 102 "                            .count()"
+ 103 "                    })"
+ 104 "                    .sum::<usize>()"
+ 105 "            })"
+ 106 "            .sum::<usize>();"
+ 107 ""
+ 108 "        format!("
+ 109 "            \"{}\\n\\n{}\\n\\n{affected_files} files affected, {} additions, {} deletions\","
+ 110 "            self.serialise_changes(),"
+ 111 "            utils::generate_blame_tree(&current_upstream, &tree_map, &blob_map),"
+ 112 "            addition,"
+ 113 "            deletion"
+ 114 "        )"
+ 115 "    }"
+ 116 ""
= LOCAL 1749000930085 "detach%20and%20some%20other%20stuff" "" no_one
+ F . .relic_ignore
=
| . .relic_ignore
+ 0 "-- Added by Relic: Automatically ignore all git content"
+ 1 ".git/"
+ 2 ".gitignore"
+ 4 "target/"
| .%2Fsrc commit.rs
+ 11 "const PENDING_TAG: &str = \"LOCAL\";"
+ 12 ""
+ 24 "    pub fn hash(&self) -> String {"
+ 25 "        sha256::digest(self.serialise())"
+ 26 "    }"
+ 27 ""
- 50 "                .map_or(\"LOCAL\".to_string(), |i| format!(\"{:06x}\", i).clone()),"
+ 56 "                .map_or(PENDING_TAG.to_string(), |i| format!(\"{:06x}\", i).clone()),"
| .%2Fsrc content_set.rs
+ 10 "pub const DEFAULT_IGNORE: &str = r#\"-- Added by Relic: Automatically ignore all git content"
+ 11 ".git/"
+ 12 ".gitignore\"#;"
+ 13 ""
+ 50 "            // skip comments"
+ 51 "            if line.starts_with(\"-- \") {"
+ 52 "                continue;"
+ 53 "            }"
+ 54 ""
| .%2Fsrc main.rs
+ 19 "use state::init;"
- 43 ""
- 44 "pub fn init(_: &mut State, _: &ArgMatches) {}"
+ 72 "            state::clone,"
+ 73 "            Command::new(\"clone\").about(\"Clone a remote Relic repository in the current directory.\")"
+ 74 "        ),"
+ 75 "        ("
+ 76 "            state::detach,"
+ 77 "            Command::new(\"detach\").about(\"Completely removes Relic from the current directory.\")"
+ 78 "        ),"
+ 79 "        ("
- 177 "    match State::create(PathBuf::from(\".\")) {"
- 178 "        Ok(mut s) => {"
- 179 "            let c = command_handler.get_matches();"
- 180 "            let (command_name, sub_matches) = c.subcommand().unwrap();"
- 181 "            match commands.get(command_name) {"
+ 184 "    let s = State::create(PathBuf::from(\".\"));"
+ 185 ""
+ 186 "    let c = command_handler.get_matches();"
+ 187 "    let (command_name, sub_matches) = c.subcommand().unwrap();"
+ 188 ""
+ 189 "    // TODO : shorten and undry this"
+ 190 "    if let Ok(mut s) = s {"
+ 191 "        match command_name {"
+ 192 "            \"clone\" | \"init\" => {"
+ 193 "                // let this run only for"
+ 194 "                // clone, init"
+ 195 "                println!(\"Unable to '{command_name}' an already existing Relic repository.\");"
+ 196 "                return;"
+ 197 "            }"
+ 198 "            _ => match commands.get(command_name) {"
+ 205 "            },"
+ 206 "        }"
+ 207 "    } else {"
+ 208 "        match command_name {"
+ 209 "            \"clone\" | \"init\" => {"
+ 210 "                // let this run only for"
+ 211 "                // clone, init"
+ 212 "                match commands.get(command_name) {"
+ 213 "                    Some(command) => {"
+ 214 "                        command(&mut State::empty(), sub_matches);"
+ 215 "                    }"
+ 216 "                    None => {"
+ 217 "                        unimplemented!(\"Relic Error, command not defined.\");"
+ 218 "                    }"
+ 219 "                }"
- 189 "        }"
- 190 "        Err(e) => {"
- 191 "            panic!(\"main.rs (main) {e:?} error encountered.\");"
+ 221 "            _ => {"
+ 222 "                println!(\"No Relic repository found in current directory. Consider executing 'relic init' or 'relic clone'.\");"
+ 223 "                return;"
+ 224 "            }"
| .%2Fsrc state.rs
+ 0 "use clap::ArgMatches;"
- 11 "    content_set::{ContentSet, IgnoreSet, TrackingSet},"
+ 12 "    content_set::{self, ContentSet, IgnoreSet, TrackingSet},"
+ 27 "        // needs to store current upstream commit"
+ 28 "        // local commits assigned an id?"
- 48 "                None => return Err(RelicError::ConfigurationIncorrect),"
+ 51 "                // TODO : implement something better for this?"
+ 52 "                None => Directory::new(), // None => return Err(RelicError::ConfigurationIncorrect),"
- 111 "                    if file_name.starts_with(\".\") {"
- 112 "                        continue;"
- 113 "                    }"
+ 115 "                    // if file_name.starts_with(\".\") {"
+ 116 "                    //     continue;"
+ 117 "                    // }"
+ 238 "pub fn init(_: &mut State, _: &ArgMatches) {"
+ 239 "    // create"
+ 240 "    // .relic"
+ 241 "    //      history/ (empty)"
+ 242 "    //      pending/ (empty)"
+ 243 "    //      root (empty)"
+ 244 "    //      tracked (empty)"
+ 245 "    //      upstream (empty)"
+ 246 "    // .relic_ignore (use default (const in content_set))"
+ 247 ""
+ 248 "    // if origin is set"
+ 249 "    // update root"
+ 250 "    // update upstream"
+ 251 ""
+ 252 "    let _ = fs::create_dir(\".relic\");"
+ 253 "    let _ = fs::create_dir(\".relic/history\");"
+ 254 "    let _ = fs::create_dir(\".relic/pending\");"
+ 255 "    let _ = fs::write(\".relic/root\", \"\");"
+ 256 "    let _ = fs::write(\".relic/tracked\", \"\");"
+ 257 "    let _ = fs::write(\".relic/pending\", \"\");"
+ 258 "    let _ = fs::write("
+ 259 "        \".relic/upstream\","
+ 260 "        r#\"{"
+ 261 "    \"path\": \"\","
+ 262 "    \"name\": \"\","
+ 263 "    \"content\": []"
+ 264 "}\"#,"
+ 265 "    );"
+ 266 ""
+ 267 "    let _ = fs::write(\".relic_ignore\", content_set::DEFAULT_IGNORE);"
+ 268 ""
+ 269 "    println!(\"Empty Relic repository created.\");"
+ 270 "}"
+ 271 ""
+ 272 "pub fn clone(_: &mut State, _: &ArgMatches) {}"
+ 273 ""
+ 274 "pub fn detach(_: &mut State, _: &ArgMatches) {"
+ 275 "    let _ = fs::remove_dir_all(\".relic\");"
+ 276 "    let _ = fs::remove_file(\".relic_ignore\");"
+ 277 ""
+ 278 "    println!(\"Relic repository successfully removed.\");"
+ 279 "}"
+ 280 ""
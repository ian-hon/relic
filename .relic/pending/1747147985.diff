= LOCAL 1747147985 "lorem%20ipsum%20dolor%20sit%20amet" "" no_one
+ F "./Cargo.lock" "Cargo.lock"
+ D "./lorem" "lorem"
+ D "./lorem/ipsum" "ipsum"
+ F "./lorem/ipsum/something_else" "something_else"
+ F "./lorem/ipsum/saturn" "saturn"
+ F "./lorem/ipsum/jupiter" "jupiter"
+ D "./lorem/ipsum/dolor" "dolor"
+ F "./lorem/ipsum/dolor/titan" "titan"
+ F "./lorem/earth" "earth"
+ F "./lorem/pluto" "pluto"
+ F "./lorem/mars" "mars"
+ F "./Cargo.toml" "Cargo.toml"
+ D "./src" "src"
+ F "./src/utils.rs" "utils.rs"
+ F "./src/commit.rs" "commit.rs"
+ F "./src/error.rs" "error.rs"
+ F "./src/state.rs" "state.rs"
+ F "./src/branch.rs" "branch.rs"
+ F "./src/stash.rs" "stash.rs"
+ F "./src/change.rs" "change.rs"
+ F "./src/ignore.rs" "ignore.rs"
+ F "./src/content.rs" "content.rs"
+ F "./src/main.rs" "main.rs"
+ F "./src/relic.rs" "relic.rs"
=
| "./src/ignore.rs"
+ 0 "use std::collections::HashSet;\n"
+ 1 "\n"
+ 2 "pub struct IgnoreSet {\n"
+ 3 "    pub dir_ignore: HashSet<String>,\n"
+ 4 "    pub file_ignore: HashSet<String>\n"
+ 5 "}\n"
+ 6 "impl IgnoreSet {\n"
+ 7 "    pub fn create(content: String) -> IgnoreSet {\n"
+ 8 "        let mut result = IgnoreSet {\n"
+ 9 "            dir_ignore: HashSet::new(),\n"
+ 10 "            file_ignore: HashSet::new()\n"
+ 11 "        };\n"
+ 12 "\n"
+ 13 "        // always ignore the .relic directory\n"
+ 14 "        result.dir_ignore.insert(\".relic\".to_string());\n"
+ 15 "\n"
+ 16 "        for line in content.split(\"\\n\") {\n"
+ 17 "            if line.is_empty() {\n"
+ 18 "                continue;\n"
+ 19 "            }\n"
+ 20 "\n"
+ 21 "            // doesnt take into account cases like \n"
+ 22 "            // some_directory// <- double slashes\n"
+ 23 "            if line.ends_with(\"/\") {\n"
+ 24 "                let i = line[0..line.len() - 1].to_string();\n"
+ 25 "                if i.is_empty() {\n"
+ 26 "                    continue;\n"
+ 27 "                }\n"
+ 28 "\n"
+ 29 "                result.dir_ignore.insert(i);\n"
+ 30 "            } else {\n"
+ 31 "                result.file_ignore.insert(line.to_string());\n"
+ 32 "            }\n"
+ 33 "        }\n"
+ 34 "\n"
+ 35 "        result\n"
+ 36 "    }\n"
+ 37 "}\n"
| "./src/commit.rs"
+ 0 "use std::collections::HashSet;\n"
+ 1 "\n"
+ 2 "use clap::ArgMatches;\n"
+ 3 "\n"
+ 4 "use crate::{change::Change, state::State, utils};\n"
+ 5 "\n"
+ 6 "pub struct Commit {\n"
+ 7 "    pub id: Option<u32>,\n"
+ 8 "    pub message: String,\n"
+ 9 "    pub description: String,\n"
+ 10 "    pub change: Change,\n"
+ 11 "    pub timestamp: u128,\n"
+ 12 "\n"
+ 13 "    pub author: String\n"
+ 14 "}\n"
+ 15 "impl Commit {\n"
+ 16 "    pub fn serialise(&self) -> String {\n"
+ 17 "        format!(\"= {} {} {:?} {:?} {}\\n{}\",\n"
+ 18 "            self.id.map_or(\"LOCAL\".to_string(), |i| format!(\"{:06x}\", i).clone()),\n"
+ 19 "            self.timestamp,\n"
+ 20 "            urlencoding::encode(&self.message).to_string(),\n"
+ 21 "            urlencoding::encode(&self.description).to_string(),\n"
+ 22 "            self.author,\n"
+ 23 "            self.change.serialise_changes()\n"
+ 24 "        )\n"
+ 25 "    }\n"
+ 26 "}\n"
+ 27 "\n"
+ 28 "\n"
+ 29 "pub fn add(state: State, args: Vec<String>) {\n"
+ 30 "\n"
+ 31 "}\n"
+ 32 "\n"
+ 33 "pub fn commit(state: State, args: &ArgMatches) {\n"
+ 34 "    // push into pending stage\n"
+ 35 "    // update upstream\n"
+ 36 "\n"
+ 37 "    // everything after the first line will be generated by Change::serialise_change\n"
+ 38 "r#\"= {commit id} {unix timestamp of commit} {message} {description} {author}\n"
+ 39 "+ D \"lorem/ipsum/dolor\"\n"
+ 40 "+ F \"lorem/ipsum/dolor/earth.txt\" \"earth.txt\"\n"
+ 41 "- D \"lorem/sit\"\n"
+ 42 "=\n"
+ 43 "| \"lorem/ipsum/dolor/earth.txt\"\n"
+ 44 "+ 3 asdfsdf\n"
+ 45 "+ 5 sfsdf\n"
+ 46 "- 7\n"
+ 47 "| \"lorem/ipsum/saturn/txt\"\n"
+ 48 "+ 4 lsdfljs\"#;\n"
+ 49 "    let message = args.get_one::<String>(\"message\").unwrap().clone();\n"
+ 50 "    let description = args.get_one::<String>(\"description\").map_or(\"\".to_string(), String::clone);\n"
+ 51 "\n"
+ 52 "    let commit = Commit {\n"
+ 53 "        id: None,\n"
+ 54 "        message,\n"
+ 55 "        description,\n"
+ 56 "        change: state.get_changes(),\n"
+ 57 "        timestamp: utils::get_time(),\n"
+ 58 "        author: \"no_one\".to_string()\n"
+ 59 "    };\n"
+ 60 "\n"
+ 61 "    state.pending_add(commit);\n"
+ 62 "    // update upstream\n"
+ 63 "    // TODO : only update added files, ignore the rest\n"
+ 64 "    state.update_upstream(HashSet::new());\n"
+ 65 "}\n"
+ 66 "\n"
+ 67 "pub fn push(state: State, args: &ArgMatches) {\n"
+ 68 "\n"
+ 69 "}\n"
+ 70 "\n"
+ 71 "pub fn pull(state: State, args: &ArgMatches) {\n"
+ 72 "\n"
+ 73 "}\n"
+ 74 "\n"
+ 75 "pub fn fetch(state: State, args: &ArgMatches) {\n"
+ 76 "\n"
+ 77 "}\n"
+ 78 "\n"
+ 79 "pub fn cherry(state: State, args: &ArgMatches) {\n"
+ 80 "    \n"
+ 81 "}\n"
+ 82 "\n"
+ 83 "pub fn rollback(state: State, args: &ArgMatches) {\n"
+ 84 "\n"
+ 85 "}\n"
| "./src/error.rs"
+ 0 "use serde::{Deserialize, Serialize};\n"
+ 1 "\n"
+ 2 "#[derive(Debug, Serialize, Deserialize)]\n"
+ 3 "pub enum RelicError {\n"
+ 4 "    FileCantOpen,\n"
+ 5 "    IgnoredFile,\n"
+ 6 "    ConfigurationIncorrect\n"
+ 7 "}\n"
| "./src/stash.rs"
+ 0 "use clap::ArgMatches;\n"
+ 1 "\n"
+ 2 "use crate::state::State;\n"
+ 3 "\n"
+ 4 "pub fn stash(state: State, args: &ArgMatches) {\n"
+ 5 "\n"
+ 6 "}\n"
+ 7 "\n"
+ 8 "pub fn restore(state: State, args: &ArgMatches) {\n"
+ 9 "\n"
+ 10 "}\n"
| "./lorem/mars"
+ 0 "sldfjsljdkf\n"
+ 1 "lajsdlfjlsfd\n"
| "./lorem/earth"
+ 0 "lorem\n"
+ 1 "ipsum\n"
+ 2 "do\n"
+ 3 "sit\n"
+ 4 "amet\n"
+ 5 "asldjflsjfjsdlk\n"
+ 6 "klasjdflskdf\n"
| "./src/content.rs"
+ 0 "use std::fs;\n"
+ 1 "\n"
+ 2 "use serde::{Deserialize, Serialize};\n"
+ 3 "\n"
+ 4 "use crate::error::RelicError;\n"
+ 5 "\n"
+ 6 "#[derive(Debug, Serialize, Deserialize, Clone)]\n"
+ 7 "pub enum Content {\n"
+ 8 "    Directory(Directory),\n"
+ 9 "    File(File),\n"
+ 10 "}\n"
+ 11 "\n"
+ 12 "#[derive(Debug, Serialize, Deserialize, Clone)]\n"
+ 13 "pub struct File {\n"
+ 14 "    pub name: String,\n"
+ 15 "    pub content: String,\n"
+ 16 "}\n"
+ 17 "\n"
+ 18 "impl File {\n"
+ 19 "    pub fn new() -> File {\n"
+ 20 "        File {\n"
+ 21 "            name: \"\".to_string(),\n"
+ 22 "            content: \"\".to_string()\n"
+ 23 "        }\n"
+ 24 "    }\n"
+ 25 "\n"
+ 26 "    pub fn create(name: String, path: String) -> Result<File, RelicError> {\n"
+ 27 "        match fs::read_to_string(path) {\n"
+ 28 "            Ok(content) => {\n"
+ 29 "                Ok(File {\n"
+ 30 "                    name: name,\n"
+ 31 "                    content: content\n"
+ 32 "                })\n"
+ 33 "            },\n"
+ 34 "            Err(_) => {\n"
+ 35 "                // println!(\"Error creating file : {e}\");\n"
+ 36 "                Err(RelicError::FileCantOpen)\n"
+ 37 "            }\n"
+ 38 "        }\n"
+ 39 "    }\n"
+ 40 "}\n"
+ 41 "\n"
+ 42 "#[derive(Debug, Serialize, Deserialize, Clone)]\n"
+ 43 "pub struct Directory {\n"
+ 44 "    pub name: String,\n"
+ 45 "    pub content: Vec<Content>\n"
+ 46 "}\n"
+ 47 "\n"
+ 48 "impl Directory {\n"
+ 49 "    pub fn new() -> Directory {\n"
+ 50 "        Directory {\n"
+ 51 "            name: \"\".to_string(),\n"
+ 52 "            content: vec![]\n"
+ 53 "        }\n"
+ 54 "    }\n"
+ 55 "\n"
+ 56 "    pub fn deserialise(s: String) -> Option<Directory> {\n"
+ 57 "        match serde_json::from_str(&s) {\n"
+ 58 "            Ok(d) => Some(d),\n"
+ 59 "            _ => None\n"
+ 60 "        }\n"
+ 61 "    }\n"
+ 62 "\n"
+ 63 "    pub fn serialise(&self) -> String {\n"
+ 64 "        serde_json::to_string(&self).unwrap()\n"
+ 65 "    }\n"
+ 66 "}\n"
| "./src/utils.rs"
+ 0 "use std::time::{SystemTime, UNIX_EPOCH};\n"
+ 1 "\n"
+ 2 "use crate::{content::Content, state::State};\n"
+ 3 "\n"
+ 4 "pub fn get_value(args: &Vec<String>, key: &str) -> Option<String> {\n"
+ 5 "    for (index, i) in args.iter().enumerate() {\n"
+ 6 "        if i.starts_with(\"-\") && (i[1..] == key[..]) {\n"
+ 7 "\n"
+ 8 "        }\n"
+ 9 "    }\n"
+ 10 "\n"
+ 11 "    None\n"
+ 12 "}\n"
+ 13 "\n"
+ 14 "pub fn generate_tree(state: &State) -> String {\n"
+ 15 "    return fetch_contents(&Content::Directory(state.current.clone()));\n"
+ 16 "}\n"
+ 17 "\n"
+ 18 "fn fetch_contents(c: &Content) -> String {\n"
+ 19 "    let mut result = vec![];\n"
+ 20 "\n"
+ 21 "    match c {\n"
+ 22 "        Content::Directory(d) => {\n"
+ 23 "            let mut r = vec![d.name.clone()];\n"
+ 24 "            if d.content.len() >= 1 {\n"
+ 25 "                let length = d.content.len() - 1;\n"
+ 26 "                for (index, i) in d.content.iter().enumerate() {\n"
+ 27 "                    for (inner_index, line) in fetch_contents(i).split(\"\\n\").enumerate() {\n"
+ 28 "                        r.push(format!(\" {} {line}\", if index == length { if inner_index == 0 { \"└\" } else { \"\" } } else { if inner_index == 0 { \"├\" } else { \"│\" } }));\n"
+ 29 "                    }\n"
+ 30 "                }\n"
+ 31 "            }\n"
+ 32 "            result.push(r.join(\"\\n\"));\n"
+ 33 "        },\n"
+ 34 "        Content::File(f) => {\n"
+ 35 "            result.push(f.name.clone());\n"
+ 36 "        }\n"
+ 37 "    }\n"
+ 38 "\n"
+ 39 "    result.join(\"\\n\")\n"
+ 40 "}\n"
+ 41 "\n"
+ 42 "pub fn get_time() -> u128 {\n"
+ 43 "    SystemTime::now()\n"
+ 44 "        .duration_since(UNIX_EPOCH)\n"
+ 45 "        .expect(\"time went backwards (???)\")\n"
+ 46 "        .as_secs() as u128\n"
+ 47 "}\n"
| "./src/main.rs"
+ 0 "use std::fs;\n"
+ 1 "use std::path::Path;\n"
+ 2 "use std::{collections::HashMap, env};\n"
+ 3 "\n"
+ 4 "mod error;\n"
+ 5 "mod ignore;\n"
+ 6 "mod state;\n"
+ 7 "mod utils;\n"
+ 8 "\n"
+ 9 "mod relic;\n"
+ 10 "mod commit;\n"
+ 11 "mod branch;\n"
+ 12 "mod stash;\n"
+ 13 "\n"
+ 14 "mod content;\n"
+ 15 "mod change;\n"
+ 16 "\n"
+ 17 "use clap::{arg, ArgMatches, Command};\n"
+ 18 "use relic::Relic;\n"
+ 19 "use change::Change;\n"
+ 20 "use ignore::IgnoreSet;\n"
+ 21 "use utils::generate_tree;\n"
+ 22 "\n"
+ 23 "use crate::commit::{add, commit, push, pull, fetch, cherry, rollback};\n"
+ 24 "use crate::branch::branch;\n"
+ 25 "use crate::stash::{stash, restore};\n"
+ 26 "use crate::state::State;\n"
+ 27 "\n"
+ 28 "// add\n"
+ 29 "// commit {message}\n"
+ 30 "// push\n"
+ 31 "// pull\n"
+ 32 "// fetch\n"
+ 33 "// branch {name}\n"
+ 34 "//      will change to that branch\n"
+ 35 "//      if branch doesnt exist, create\n"
+ 36 "//      ask to create stash (if changes present)\n"
+ 37 "// stash {name|optional}\n"
+ 38 "//      stashes are bound to a branch\n"
+ 39 "//      optional to have a name\n"
+ 40 "// restore\n"
+ 41 "//      select stash to restore\n"
+ 42 "// rollback\n"
+ 43 "//      resets to current head\n"
+ 44 "// cherry {commit hash}\n"
+ 45 "\n"
+ 46 "pub fn init(_: State, _: &ArgMatches) {\n"
+ 47 "\n"
+ 48 "}\n"
+ 49 "\n"
+ 50 "fn main() {\n"
+ 51 "    // #region commands\n"
+ 52 "    // TODO : automate this\n"
+ 53 "    let command_handler = Command::new(\"relic\")\n"
+ 54 "        .about(r#\"This is the Relic Version Control System.\n"
+ 55 "\n"
+ 56 "The best way to learn is to stupidly and\n"
+ 57 "blindly reinvent the wheel.\n"
+ 58 "\n"
+ 59 "Relic is a simple hobby project, because\n"
+ 60 "remaking Git sounded fun and interesting.\n"
+ 61 "\n"
+ 62 "Most common features like committing,\n"
+ 63 "pushing and pulling, are implemented.\"#)\n"
+ 64 "        .subcommand_required(true)\n"
+ 65 "        .arg_required_else_help(true)\n"
+ 66 "        .subcommand(\n"
+ 67 "            Command::new(\"commit\")\n"
+ 68 "                .about(\"Commit current changes.\")\n"
+ 69 "                .arg_required_else_help(true)\n"
+ 70 "                .arg(arg!(-m --message <MESSAGE> \"Commit message\").required(true))\n"
+ 71 "                .arg(arg!(-d --description <DESCRIPTION> \"Commit description\"))\n"
+ 72 "        )\n"
+ 73 "        .subcommand(\n"
+ 74 "            Command::new(\"init\")\n"
+ 75 "                .about(\"Initialises a Relic repository in the current directory.\")\n"
+ 76 "        )\n"
+ 77 "        .subcommand(\n"
+ 78 "            Command::new(\"push\")\n"
+ 79 "                .about(\"Pushes local changes to remote.\")\n"
+ 80 "        )\n"
+ 81 "        .subcommand(\n"
+ 82 "            Command::new(\"pull\")\n"
+ 83 "                .about(\"Pull changes from remote to local.\")\n"
+ 84 "        )\n"
+ 85 "        .subcommand(\n"
+ 86 "            Command::new(\"fetch\")\n"
+ 87 "                .about(\"Check remote for new changes.\")\n"
+ 88 "        )\n"
+ 89 "        .subcommand(\n"
+ 90 "            Command::new(\"branch\")\n"
+ 91 "                .about(\"\")\n"
+ 92 "        )\n"
+ 93 "        .subcommand(\n"
+ 94 "            Command::new(\"stash\")\n"
+ 95 "                // pseudo-commits basically\n"
+ 96 "                // clear stash after a commit\n"
+ 97 "                // stash create\n"
+ 98 "                // stash view\n"
+ 99 "                // stash restore\n"
+ 100 "                // stash delete\n"
+ 101 "                .about(\"\")\n"
+ 102 "        )\n"
+ 103 "        .subcommand(\n"
+ 104 "            Command::new(\"rollback\")\n"
+ 105 "                .about(\"Discard all current changes. Rolls back to most recent commit (or pending commit).\")\n"
+ 106 "        )\n"
+ 107 "        .subcommand(\n"
+ 108 "            Command::new(\"cherry\")\n"
+ 109 "                .about(\"Go to specific commit.\")\n"
+ 110 "        )\n"
+ 111 "        .subcommand(\n"
+ 112 "            Command::new(\"tree\")\n"
+ 113 "                .about(\"Generate content tree of current directory.\")\n"
+ 114 "        )\n"
+ 115 "\n"
+ 116 "        .subcommand(\n"
+ 117 "            Command::new(\"update\")\n"
+ 118 "                .about(\"DEBUG : updates stored state\")\n"
+ 119 "        )\n"
+ 120 "    ;\n"
+ 121 "\n"
+ 122 "    type CommandType = fn(State, &ArgMatches);\n"
+ 123 "    let commands: HashMap<String, CommandType> = HashMap::from_iter::<Vec<(String, CommandType)>>(vec![\n"
+ 124 "        (\"commit\".to_string(), commit),\n"
+ 125 "        (\"push\".to_string(), push),\n"
+ 126 "        (\"pull\".to_string(), pull),\n"
+ 127 "        (\"fetch\".to_string(), fetch),\n"
+ 128 "        (\"branch\".to_string(), branch),\n"
+ 129 "        (\"stash\".to_string(), stash),\n"
+ 130 "        (\"restore\".to_string(), restore),\n"
+ 131 "        (\"rollback\".to_string(), rollback),\n"
+ 132 "        (\"cherry\".to_string(), cherry),\n"
+ 133 "\n"
+ 134 "        (\"tree\".to_string(), |s, _| {\n"
+ 135 "            println!(\"{}\", generate_tree(&s));\n"
+ 136 "        }),\n"
+ 137 "\n"
+ 138 "        (\"init\".to_string(), init),\n"
+ 139 "\n"
+ 140 "        (\"update\".to_string(), |s, _| {\n"
+ 141 "            let _ = fs::write(\"./.relic/upstream\", s.serialise_state());\n"
+ 142 "        })\n"
+ 143 "    ]);\n"
+ 144 "    // #endregion\n"
+ 145 "    \n"
+ 146 "    // get current path\n"
+ 147 "    // (used to be more complicated than this, but keeping it as a relative path just makes more sense now)\n"
+ 148 "    let path = Path::new(\".\");\n"
+ 149 "    //\n"
+ 150 "\n"
+ 151 "    // get ignorance set\n"
+ 152 "    let ignore_set = IgnoreSet::create(fs::read_to_string(path.join(\".relic_ignore\")).unwrap_or(\"\".to_string()));\n"
+ 153 "    //\n"
+ 154 "\n"
+ 155 "    match State::create(\".\".to_string(), &ignore_set) {\n"
+ 156 "        Ok(s) => {\n"
+ 157 "            let c = command_handler.get_matches();\n"
+ 158 "            let (command_name, sub_matches) = c.subcommand().unwrap();\n"
+ 159 "            match commands.get(command_name) {\n"
+ 160 "                Some(command) => {\n"
+ 161 "                    command(s, sub_matches);\n"
+ 162 "                },\n"
+ 163 "                None => {\n"
+ 164 "                    println!(\"Relic Error, command not defined.\")\n"
+ 165 "                }\n"
+ 166 "            }\n"
+ 167 "        },\n"
+ 168 "        Err(e) => {\n"
+ 169 "            println!(\"{e:?} error encountered.\");\n"
+ 170 "        }\n"
+ 171 "    }\n"
+ 172 "}\n"
| "./Cargo.toml"
+ 0 "[package]\n"
+ 1 "name = \"relic\"\n"
+ 2 "version = \"0.1.0\"\n"
+ 3 "edition = \"2021\"\n"
+ 4 "\n"
+ 5 "[dependencies]\n"
+ 6 "sha256 = \"1.5.0\"\n"
+ 7 "\n"
+ 8 "strum = \"0.26.3\"\n"
+ 9 "strum_macros = \"0.26.3\"\n"
+ 10 "\n"
+ 11 "serde = { version = \"1.0\", features = [\"derive\"] }\n"
+ 12 "serde_json = \"1.0\"\n"
+ 13 "urlencoding = \"2.1.3\"\n"
+ 14 "\n"
+ 15 "dotenv = \"0.15.0\"\n"
+ 16 "clap = \"4.5.38\"\n"
+ 17 "\n"
+ 18 "similar = \"2.7.0\"\n"
| "./Cargo.lock"
+ 0 "# This file is automatically @generated by Cargo.\n"
+ 1 "# It is not intended for manual editing.\n"
+ 2 "version = 3\n"
+ 3 "\n"
+ 4 "[[package]]\n"
+ 5 "name = \"addr2line\"\n"
+ 6 "version = \"0.24.2\"\n"
+ 7 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 8 "checksum = \"dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1\"\n"
+ 9 "dependencies = [\n"
+ 10 " \"gimli\",\n"
+ 11 "]\n"
+ 12 "\n"
+ 13 "[[package]]\n"
+ 14 "name = \"adler2\"\n"
+ 15 "version = \"2.0.0\"\n"
+ 16 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 17 "checksum = \"512761e0bb2578dd7380c6baaa0f4ce03e84f95e960231d1dec8bf4d7d6e2627\"\n"
+ 18 "\n"
+ 19 "[[package]]\n"
+ 20 "name = \"anstream\"\n"
+ 21 "version = \"0.6.18\"\n"
+ 22 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 23 "checksum = \"8acc5369981196006228e28809f761875c0327210a891e941f4c683b3a99529b\"\n"
+ 24 "dependencies = [\n"
+ 25 " \"anstyle\",\n"
+ 26 " \"anstyle-parse\",\n"
+ 27 " \"anstyle-query\",\n"
+ 28 " \"anstyle-wincon\",\n"
+ 29 " \"colorchoice\",\n"
+ 30 " \"is_terminal_polyfill\",\n"
+ 31 " \"utf8parse\",\n"
+ 32 "]\n"
+ 33 "\n"
+ 34 "[[package]]\n"
+ 35 "name = \"anstyle\"\n"
+ 36 "version = \"1.0.10\"\n"
+ 37 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 38 "checksum = \"55cc3b69f167a1ef2e161439aa98aed94e6028e5f9a59be9a6ffb47aef1651f9\"\n"
+ 39 "\n"
+ 40 "[[package]]\n"
+ 41 "name = \"anstyle-parse\"\n"
+ 42 "version = \"0.2.6\"\n"
+ 43 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 44 "checksum = \"3b2d16507662817a6a20a9ea92df6652ee4f94f914589377d69f3b21bc5798a9\"\n"
+ 45 "dependencies = [\n"
+ 46 " \"utf8parse\",\n"
+ 47 "]\n"
+ 48 "\n"
+ 49 "[[package]]\n"
+ 50 "name = \"anstyle-query\"\n"
+ 51 "version = \"1.1.2\"\n"
+ 52 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 53 "checksum = \"79947af37f4177cfead1110013d678905c37501914fba0efea834c3fe9a8d60c\"\n"
+ 54 "dependencies = [\n"
+ 55 " \"windows-sys\",\n"
+ 56 "]\n"
+ 57 "\n"
+ 58 "[[package]]\n"
+ 59 "name = \"anstyle-wincon\"\n"
+ 60 "version = \"3.0.7\"\n"
+ 61 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 62 "checksum = \"ca3534e77181a9cc07539ad51f2141fe32f6c3ffd4df76db8ad92346b003ae4e\"\n"
+ 63 "dependencies = [\n"
+ 64 " \"anstyle\",\n"
+ 65 " \"once_cell\",\n"
+ 66 " \"windows-sys\",\n"
+ 67 "]\n"
+ 68 "\n"
+ 69 "[[package]]\n"
+ 70 "name = \"async-trait\"\n"
+ 71 "version = \"0.1.88\"\n"
+ 72 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 73 "checksum = \"e539d3fca749fcee5236ab05e93a52867dd549cc157c8cb7f99595f3cedffdb5\"\n"
+ 74 "dependencies = [\n"
+ 75 " \"proc-macro2\",\n"
+ 76 " \"quote\",\n"
+ 77 " \"syn\",\n"
+ 78 "]\n"
+ 79 "\n"
+ 80 "[[package]]\n"
+ 81 "name = \"backtrace\"\n"
+ 82 "version = \"0.3.74\"\n"
+ 83 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 84 "checksum = \"8d82cb332cdfaed17ae235a638438ac4d4839913cc2af585c3c6746e8f8bee1a\"\n"
+ 85 "dependencies = [\n"
+ 86 " \"addr2line\",\n"
+ 87 " \"cfg-if\",\n"
+ 88 " \"libc\",\n"
+ 89 " \"miniz_oxide\",\n"
+ 90 " \"object\",\n"
+ 91 " \"rustc-demangle\",\n"
+ 92 " \"windows-targets\",\n"
+ 93 "]\n"
+ 94 "\n"
+ 95 "[[package]]\n"
+ 96 "name = \"block-buffer\"\n"
+ 97 "version = \"0.10.4\"\n"
+ 98 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 99 "checksum = \"3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71\"\n"
+ 100 "dependencies = [\n"
+ 101 " \"generic-array\",\n"
+ 102 "]\n"
+ 103 "\n"
+ 104 "[[package]]\n"
+ 105 "name = \"bytes\"\n"
+ 106 "version = \"1.10.1\"\n"
+ 107 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 108 "checksum = \"d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a\"\n"
+ 109 "\n"
+ 110 "[[package]]\n"
+ 111 "name = \"cfg-if\"\n"
+ 112 "version = \"1.0.0\"\n"
+ 113 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 114 "checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n"
+ 115 "\n"
+ 116 "[[package]]\n"
+ 117 "name = \"clap\"\n"
+ 118 "version = \"4.5.38\"\n"
+ 119 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 120 "checksum = \"ed93b9805f8ba930df42c2590f05453d5ec36cbb85d018868a5b24d31f6ac000\"\n"
+ 121 "dependencies = [\n"
+ 122 " \"clap_builder\",\n"
+ 123 "]\n"
+ 124 "\n"
+ 125 "[[package]]\n"
+ 126 "name = \"clap_builder\"\n"
+ 127 "version = \"4.5.38\"\n"
+ 128 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 129 "checksum = \"379026ff283facf611b0ea629334361c4211d1b12ee01024eec1591133b04120\"\n"
+ 130 "dependencies = [\n"
+ 131 " \"anstream\",\n"
+ 132 " \"anstyle\",\n"
+ 133 " \"clap_lex\",\n"
+ 134 " \"strsim\",\n"
+ 135 "]\n"
+ 136 "\n"
+ 137 "[[package]]\n"
+ 138 "name = \"clap_lex\"\n"
+ 139 "version = \"0.7.4\"\n"
+ 140 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 141 "checksum = \"f46ad14479a25103f283c0f10005961cf086d8dc42205bb44c46ac563475dca6\"\n"
+ 142 "\n"
+ 143 "[[package]]\n"
+ 144 "name = \"colorchoice\"\n"
+ 145 "version = \"1.0.3\"\n"
+ 146 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 147 "checksum = \"5b63caa9aa9397e2d9480a9b13673856c78d8ac123288526c37d7839f2a86990\"\n"
+ 148 "\n"
+ 149 "[[package]]\n"
+ 150 "name = \"cpufeatures\"\n"
+ 151 "version = \"0.2.17\"\n"
+ 152 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 153 "checksum = \"59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280\"\n"
+ 154 "dependencies = [\n"
+ 155 " \"libc\",\n"
+ 156 "]\n"
+ 157 "\n"
+ 158 "[[package]]\n"
+ 159 "name = \"crypto-common\"\n"
+ 160 "version = \"0.1.6\"\n"
+ 161 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 162 "checksum = \"1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3\"\n"
+ 163 "dependencies = [\n"
+ 164 " \"generic-array\",\n"
+ 165 " \"typenum\",\n"
+ 166 "]\n"
+ 167 "\n"
+ 168 "[[package]]\n"
+ 169 "name = \"digest\"\n"
+ 170 "version = \"0.10.7\"\n"
+ 171 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 172 "checksum = \"9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292\"\n"
+ 173 "dependencies = [\n"
+ 174 " \"block-buffer\",\n"
+ 175 " \"crypto-common\",\n"
+ 176 "]\n"
+ 177 "\n"
+ 178 "[[package]]\n"
+ 179 "name = \"dotenv\"\n"
+ 180 "version = \"0.15.0\"\n"
+ 181 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 182 "checksum = \"77c90badedccf4105eca100756a0b1289e191f6fcbdadd3cee1d2f614f97da8f\"\n"
+ 183 "\n"
+ 184 "[[package]]\n"
+ 185 "name = \"generic-array\"\n"
+ 186 "version = \"0.14.7\"\n"
+ 187 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 188 "checksum = \"85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a\"\n"
+ 189 "dependencies = [\n"
+ 190 " \"typenum\",\n"
+ 191 " \"version_check\",\n"
+ 192 "]\n"
+ 193 "\n"
+ 194 "[[package]]\n"
+ 195 "name = \"gimli\"\n"
+ 196 "version = \"0.31.1\"\n"
+ 197 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 198 "checksum = \"07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f\"\n"
+ 199 "\n"
+ 200 "[[package]]\n"
+ 201 "name = \"heck\"\n"
+ 202 "version = \"0.5.0\"\n"
+ 203 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 204 "checksum = \"2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea\"\n"
+ 205 "\n"
+ 206 "[[package]]\n"
+ 207 "name = \"hex\"\n"
+ 208 "version = \"0.4.3\"\n"
+ 209 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 210 "checksum = \"7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70\"\n"
+ 211 "\n"
+ 212 "[[package]]\n"
+ 213 "name = \"is_terminal_polyfill\"\n"
+ 214 "version = \"1.70.1\"\n"
+ 215 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 216 "checksum = \"7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf\"\n"
+ 217 "\n"
+ 218 "[[package]]\n"
+ 219 "name = \"itoa\"\n"
+ 220 "version = \"1.0.15\"\n"
+ 221 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 222 "checksum = \"4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c\"\n"
+ 223 "\n"
+ 224 "[[package]]\n"
+ 225 "name = \"libc\"\n"
+ 226 "version = \"0.2.172\"\n"
+ 227 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 228 "checksum = \"d750af042f7ef4f724306de029d18836c26c1765a54a6a3f094cbd23a7267ffa\"\n"
+ 229 "\n"
+ 230 "[[package]]\n"
+ 231 "name = \"memchr\"\n"
+ 232 "version = \"2.7.4\"\n"
+ 233 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 234 "checksum = \"78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3\"\n"
+ 235 "\n"
+ 236 "[[package]]\n"
+ 237 "name = \"miniz_oxide\"\n"
+ 238 "version = \"0.8.8\"\n"
+ 239 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 240 "checksum = \"3be647b768db090acb35d5ec5db2b0e1f1de11133ca123b9eacf5137868f892a\"\n"
+ 241 "dependencies = [\n"
+ 242 " \"adler2\",\n"
+ 243 "]\n"
+ 244 "\n"
+ 245 "[[package]]\n"
+ 246 "name = \"object\"\n"
+ 247 "version = \"0.36.7\"\n"
+ 248 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 249 "checksum = \"62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87\"\n"
+ 250 "dependencies = [\n"
+ 251 " \"memchr\",\n"
+ 252 "]\n"
+ 253 "\n"
+ 254 "[[package]]\n"
+ 255 "name = \"once_cell\"\n"
+ 256 "version = \"1.21.3\"\n"
+ 257 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 258 "checksum = \"42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d\"\n"
+ 259 "\n"
+ 260 "[[package]]\n"
+ 261 "name = \"pin-project-lite\"\n"
+ 262 "version = \"0.2.16\"\n"
+ 263 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 264 "checksum = \"3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b\"\n"
+ 265 "\n"
+ 266 "[[package]]\n"
+ 267 "name = \"proc-macro2\"\n"
+ 268 "version = \"1.0.95\"\n"
+ 269 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 270 "checksum = \"02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778\"\n"
+ 271 "dependencies = [\n"
+ 272 " \"unicode-ident\",\n"
+ 273 "]\n"
+ 274 "\n"
+ 275 "[[package]]\n"
+ 276 "name = \"quote\"\n"
+ 277 "version = \"1.0.40\"\n"
+ 278 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 279 "checksum = \"1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d\"\n"
+ 280 "dependencies = [\n"
+ 281 " \"proc-macro2\",\n"
+ 282 "]\n"
+ 283 "\n"
+ 284 "[[package]]\n"
+ 285 "name = \"relic\"\n"
+ 286 "version = \"0.1.0\"\n"
+ 287 "dependencies = [\n"
+ 288 " \"clap\",\n"
+ 289 " \"dotenv\",\n"
+ 290 " \"serde\",\n"
+ 291 " \"serde_json\",\n"
+ 292 " \"sha256\",\n"
+ 293 " \"similar\",\n"
+ 294 " \"strum\",\n"
+ 295 " \"strum_macros\",\n"
+ 296 " \"urlencoding\",\n"
+ 297 "]\n"
+ 298 "\n"
+ 299 "[[package]]\n"
+ 300 "name = \"rustc-demangle\"\n"
+ 301 "version = \"0.1.24\"\n"
+ 302 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 303 "checksum = \"719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f\"\n"
+ 304 "\n"
+ 305 "[[package]]\n"
+ 306 "name = \"rustversion\"\n"
+ 307 "version = \"1.0.20\"\n"
+ 308 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 309 "checksum = \"eded382c5f5f786b989652c49544c4877d9f015cc22e145a5ea8ea66c2921cd2\"\n"
+ 310 "\n"
+ 311 "[[package]]\n"
+ 312 "name = \"ryu\"\n"
+ 313 "version = \"1.0.20\"\n"
+ 314 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 315 "checksum = \"28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f\"\n"
+ 316 "\n"
+ 317 "[[package]]\n"
+ 318 "name = \"serde\"\n"
+ 319 "version = \"1.0.219\"\n"
+ 320 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 321 "checksum = \"5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6\"\n"
+ 322 "dependencies = [\n"
+ 323 " \"serde_derive\",\n"
+ 324 "]\n"
+ 325 "\n"
+ 326 "[[package]]\n"
+ 327 "name = \"serde_derive\"\n"
+ 328 "version = \"1.0.219\"\n"
+ 329 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 330 "checksum = \"5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00\"\n"
+ 331 "dependencies = [\n"
+ 332 " \"proc-macro2\",\n"
+ 333 " \"quote\",\n"
+ 334 " \"syn\",\n"
+ 335 "]\n"
+ 336 "\n"
+ 337 "[[package]]\n"
+ 338 "name = \"serde_json\"\n"
+ 339 "version = \"1.0.140\"\n"
+ 340 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 341 "checksum = \"20068b6e96dc6c9bd23e01df8827e6c7e1f2fddd43c21810382803c136b99373\"\n"
+ 342 "dependencies = [\n"
+ 343 " \"itoa\",\n"
+ 344 " \"memchr\",\n"
+ 345 " \"ryu\",\n"
+ 346 " \"serde\",\n"
+ 347 "]\n"
+ 348 "\n"
+ 349 "[[package]]\n"
+ 350 "name = \"sha2\"\n"
+ 351 "version = \"0.10.8\"\n"
+ 352 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 353 "checksum = \"793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8\"\n"
+ 354 "dependencies = [\n"
+ 355 " \"cfg-if\",\n"
+ 356 " \"cpufeatures\",\n"
+ 357 " \"digest\",\n"
+ 358 "]\n"
+ 359 "\n"
+ 360 "[[package]]\n"
+ 361 "name = \"sha256\"\n"
+ 362 "version = \"1.6.0\"\n"
+ 363 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 364 "checksum = \"f880fc8562bdeb709793f00eb42a2ad0e672c4f883bbe59122b926eca935c8f6\"\n"
+ 365 "dependencies = [\n"
+ 366 " \"async-trait\",\n"
+ 367 " \"bytes\",\n"
+ 368 " \"hex\",\n"
+ 369 " \"sha2\",\n"
+ 370 " \"tokio\",\n"
+ 371 "]\n"
+ 372 "\n"
+ 373 "[[package]]\n"
+ 374 "name = \"similar\"\n"
+ 375 "version = \"2.7.0\"\n"
+ 376 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 377 "checksum = \"bbbb5d9659141646ae647b42fe094daf6c6192d1620870b449d9557f748b2daa\"\n"
+ 378 "\n"
+ 379 "[[package]]\n"
+ 380 "name = \"strsim\"\n"
+ 381 "version = \"0.11.1\"\n"
+ 382 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 383 "checksum = \"7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f\"\n"
+ 384 "\n"
+ 385 "[[package]]\n"
+ 386 "name = \"strum\"\n"
+ 387 "version = \"0.26.3\"\n"
+ 388 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 389 "checksum = \"8fec0f0aef304996cf250b31b5a10dee7980c85da9d759361292b8bca5a18f06\"\n"
+ 390 "\n"
+ 391 "[[package]]\n"
+ 392 "name = \"strum_macros\"\n"
+ 393 "version = \"0.26.4\"\n"
+ 394 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 395 "checksum = \"4c6bee85a5a24955dc440386795aa378cd9cf82acd5f764469152d2270e581be\"\n"
+ 396 "dependencies = [\n"
+ 397 " \"heck\",\n"
+ 398 " \"proc-macro2\",\n"
+ 399 " \"quote\",\n"
+ 400 " \"rustversion\",\n"
+ 401 " \"syn\",\n"
+ 402 "]\n"
+ 403 "\n"
+ 404 "[[package]]\n"
+ 405 "name = \"syn\"\n"
+ 406 "version = \"2.0.100\"\n"
+ 407 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 408 "checksum = \"b09a44accad81e1ba1cd74a32461ba89dee89095ba17b32f5d03683b1b1fc2a0\"\n"
+ 409 "dependencies = [\n"
+ 410 " \"proc-macro2\",\n"
+ 411 " \"quote\",\n"
+ 412 " \"unicode-ident\",\n"
+ 413 "]\n"
+ 414 "\n"
+ 415 "[[package]]\n"
+ 416 "name = \"tokio\"\n"
+ 417 "version = \"1.44.2\"\n"
+ 418 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 419 "checksum = \"e6b88822cbe49de4185e3a4cbf8321dd487cf5fe0c5c65695fef6346371e9c48\"\n"
+ 420 "dependencies = [\n"
+ 421 " \"backtrace\",\n"
+ 422 " \"bytes\",\n"
+ 423 " \"pin-project-lite\",\n"
+ 424 "]\n"
+ 425 "\n"
+ 426 "[[package]]\n"
+ 427 "name = \"typenum\"\n"
+ 428 "version = \"1.18.0\"\n"
+ 429 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 430 "checksum = \"1dccffe3ce07af9386bfd29e80c0ab1a8205a2fc34e4bcd40364df902cfa8f3f\"\n"
+ 431 "\n"
+ 432 "[[package]]\n"
+ 433 "name = \"unicode-ident\"\n"
+ 434 "version = \"1.0.18\"\n"
+ 435 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 436 "checksum = \"5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512\"\n"
+ 437 "\n"
+ 438 "[[package]]\n"
+ 439 "name = \"urlencoding\"\n"
+ 440 "version = \"2.1.3\"\n"
+ 441 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 442 "checksum = \"daf8dba3b7eb870caf1ddeed7bc9d2a049f3cfdfae7cb521b087cc33ae4c49da\"\n"
+ 443 "\n"
+ 444 "[[package]]\n"
+ 445 "name = \"utf8parse\"\n"
+ 446 "version = \"0.2.2\"\n"
+ 447 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 448 "checksum = \"06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821\"\n"
+ 449 "\n"
+ 450 "[[package]]\n"
+ 451 "name = \"version_check\"\n"
+ 452 "version = \"0.9.5\"\n"
+ 453 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 454 "checksum = \"0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a\"\n"
+ 455 "\n"
+ 456 "[[package]]\n"
+ 457 "name = \"windows-sys\"\n"
+ 458 "version = \"0.59.0\"\n"
+ 459 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 460 "checksum = \"1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b\"\n"
+ 461 "dependencies = [\n"
+ 462 " \"windows-targets\",\n"
+ 463 "]\n"
+ 464 "\n"
+ 465 "[[package]]\n"
+ 466 "name = \"windows-targets\"\n"
+ 467 "version = \"0.52.6\"\n"
+ 468 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 469 "checksum = \"9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973\"\n"
+ 470 "dependencies = [\n"
+ 471 " \"windows_aarch64_gnullvm\",\n"
+ 472 " \"windows_aarch64_msvc\",\n"
+ 473 " \"windows_i686_gnu\",\n"
+ 474 " \"windows_i686_gnullvm\",\n"
+ 475 " \"windows_i686_msvc\",\n"
+ 476 " \"windows_x86_64_gnu\",\n"
+ 477 " \"windows_x86_64_gnullvm\",\n"
+ 478 " \"windows_x86_64_msvc\",\n"
+ 479 "]\n"
+ 480 "\n"
+ 481 "[[package]]\n"
+ 482 "name = \"windows_aarch64_gnullvm\"\n"
+ 483 "version = \"0.52.6\"\n"
+ 484 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 485 "checksum = \"32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3\"\n"
+ 486 "\n"
+ 487 "[[package]]\n"
+ 488 "name = \"windows_aarch64_msvc\"\n"
+ 489 "version = \"0.52.6\"\n"
+ 490 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 491 "checksum = \"09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469\"\n"
+ 492 "\n"
+ 493 "[[package]]\n"
+ 494 "name = \"windows_i686_gnu\"\n"
+ 495 "version = \"0.52.6\"\n"
+ 496 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 497 "checksum = \"8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b\"\n"
+ 498 "\n"
+ 499 "[[package]]\n"
+ 500 "name = \"windows_i686_gnullvm\"\n"
+ 501 "version = \"0.52.6\"\n"
+ 502 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 503 "checksum = \"0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66\"\n"
+ 504 "\n"
+ 505 "[[package]]\n"
+ 506 "name = \"windows_i686_msvc\"\n"
+ 507 "version = \"0.52.6\"\n"
+ 508 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 509 "checksum = \"240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66\"\n"
+ 510 "\n"
+ 511 "[[package]]\n"
+ 512 "name = \"windows_x86_64_gnu\"\n"
+ 513 "version = \"0.52.6\"\n"
+ 514 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 515 "checksum = \"147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78\"\n"
+ 516 "\n"
+ 517 "[[package]]\n"
+ 518 "name = \"windows_x86_64_gnullvm\"\n"
+ 519 "version = \"0.52.6\"\n"
+ 520 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 521 "checksum = \"24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d\"\n"
+ 522 "\n"
+ 523 "[[package]]\n"
+ 524 "name = \"windows_x86_64_msvc\"\n"
+ 525 "version = \"0.52.6\"\n"
+ 526 "source = \"registry+https://github.com/rust-lang/crates.io-index\"\n"
+ 527 "checksum = \"589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec\"\n"
| "./src/branch.rs"
+ 0 "use clap::ArgMatches;\n"
+ 1 "\n"
+ 2 "use crate::state::State;\n"
+ 3 "\n"
+ 4 "pub fn branch(state: State, args: &ArgMatches) {\n"
+ 5 "\n"
+ 6 "}\n"
| "./src/change.rs"
+ 0 "use std::{collections::{HashMap, HashSet}, path::Path};\n"
+ 1 "\n"
+ 2 "use similar::{ChangeTag, TextDiff};\n"
+ 3 "\n"
+ 4 "use crate::content::{Content, Directory, File};\n"
+ 5 "\n"
+ 6 "#[derive(Debug)]\n"
+ 7 "pub struct Change {\n"
+ 8 "    pub container_modifications: Vec<ContainerModification>,\n"
+ 9 "    pub modifications: Vec<Modification>\n"
+ 10 "}\n"
+ 11 "impl Change {\n"
+ 12 "    pub fn serialise_changes(&self) -> String {\n"
+ 13 "// + D \"lorem/ipsum/dolor\"\n"
+ 14 "// + F \"lorem/ipsum/dolor/earth.txt\" \"earth.txt\"\n"
+ 15 "// - D \"lorem/sit\"\n"
+ 16 "// =\n"
+ 17 "// | \"lorem/ipsum/dolor/earth.txt\"\n"
+ 18 "// + 3 asdfsdf\n"
+ 19 "// + 5 sfsdf\n"
+ 20 "// - 7\n"
+ 21 "// | \"lorem/ipsum/saturn/txt\"\n"
+ 22 "// + 4 lsdfljs\n"
+ 23 "        \n"
+ 24 "        let mut result: Vec<String> = vec![];\n"
+ 25 "\n"
+ 26 "        for c_m in &self.container_modifications {\n"
+ 27 "            result.push(\n"
+ 28 "                match c_m {\n"
+ 29 "                    ContainerModification::CreateDirectory(p, n) => {\n"
+ 30 "                        format!(\"+ D {p:?} {n:?}\")\n"
+ 31 "                    },\n"
+ 32 "                    ContainerModification::DeleteDirectory(p) => {\n"
+ 33 "                        format!(\"- D {p:?}\")\n"
+ 34 "                    },\n"
+ 35 "                    ContainerModification::CreateFile(p, n) => {\n"
+ 36 "                        format!(\"+ F {p:?} {n:?}\")\n"
+ 37 "                    },\n"
+ 38 "                    ContainerModification::DeleteFile(p) => {\n"
+ 39 "                        format!(\"- F {p:?}\")\n"
+ 40 "                    }\n"
+ 41 "                }\n"
+ 42 "            );\n"
+ 43 "        }\n"
+ 44 "\n"
+ 45 "        result.push(\"=\".to_string());\n"
+ 46 "\n"
+ 47 "        let mut map = HashMap::new();\n"
+ 48 "        for modification in &self.modifications {\n"
+ 49 "            let path = match modification {\n"
+ 50 "                Modification::Create(path, _, _, _) => path.clone(),\n"
+ 51 "                Modification::Delete(path, _, _) => path.clone()\n"
+ 52 "            };\n"
+ 53 "            map.entry(path).or_insert(vec![]).push(modification.clone());\n"
+ 54 "        }\n"
+ 55 "\n"
+ 56 "        for (path, modifications) in map {\n"
+ 57 "            result.push(format!(\"| {path:?}\"));\n"
+ 58 "            for m in modifications {\n"
+ 59 "                result.push(\n"
+ 60 "                    match m {\n"
+ 61 "                        Modification::Create(_, _, line, content) => format!(\"+ {line} {content:?}\"),\n"
+ 62 "                        Modification::Delete(_, _, line) => format!(\"- {line}\")\n"
+ 63 "                    }\n"
+ 64 "                )\n"
+ 65 "            }\n"
+ 66 "        }\n"
+ 67 "\n"
+ 68 "        result.join(\"\\n\")\n"
+ 69 "    }\n"
+ 70 "\n"
+ 71 "    pub fn get_change(path: String, upstream_file: &File, current_file: &File) -> Vec<Modification> {\n"
+ 72 "        // https://blog.jcoglan.com/2017/02/15/the-myers-diff-algorithm-part-2/\n"
+ 73 "        // for our change algorithm, we will be using myers diff algorithm\n"
+ 74 "        // basically a shortest distance problem, with downwards, rightwards and diagonal directions as movement choices\n"
+ 75 "        // (note that diagonal movements do not contribute towards the distance)\n"
+ 76 "\n"
+ 77 "        let upstream = upstream_file.content.clone();\n"
+ 78 "        let current = current_file.content.clone();\n"
+ 79 "\n"
+ 80 "        // TODO : compare hashes instead of files\n"
+ 81 "        if upstream == current {\n"
+ 82 "            return vec![];\n"
+ 83 "        }\n"
+ 84 "\n"
+ 85 "        let mut result = vec![];\n"
+ 86 "        let diff = TextDiff::from_lines(&upstream, &current);\n"
+ 87 "\n"
+ 88 "        for change in diff\n"
+ 89 "            .iter_all_changes()\n"
+ 90 "            .filter_map(|c| match c.tag() {\n"
+ 91 "                ChangeTag::Equal => None,\n"
+ 92 "                _ => Some(c)\n"
+ 93 "            }\n"
+ 94 "        ) {\n"
+ 95 "            result.push(\n"
+ 96 "                match change.tag() {\n"
+ 97 "                    ChangeTag::Delete => Modification::Delete(\n"
+ 98 "                        path.clone(),\n"
+ 99 "                        current_file.name.clone(),\n"
+ 100 "                        change.old_index().unwrap()\n"
+ 101 "                    ),\n"
+ 102 "                    ChangeTag::Insert => Modification::Create(\n"
+ 103 "                        path.clone(),\n"
+ 104 "                        current_file.name.clone(),\n"
+ 105 "                        change.new_index().unwrap(),\n"
+ 106 "                        change.to_string()\n"
+ 107 "                    ),\n"
+ 108 "                    _ => panic!()\n"
+ 109 "                }\n"
+ 110 "            )\n"
+ 111 "        }\n"
+ 112 "\n"
+ 113 "        result\n"
+ 114 "    }\n"
+ 115 "\n"
+ 116 "    pub fn get_change_all(upstream: &Directory, current: &Directory, path: &Path) -> Change {\n"
+ 117 "        // assume that both current and previous have the same directory names\n"
+ 118 "        // has to be bfs\n"
+ 119 "\n"
+ 120 "        // initialise current state set\n"
+ 121 "        let mut current_set = HashSet::new();\n"
+ 122 "        let mut current_map = HashMap::new();\n"
+ 123 "        for c in &current.content {\n"
+ 124 "            match c {\n"
+ 125 "                Content::Directory(d) => {\n"
+ 126 "                    current_set.insert((d.name.clone(), false));\n"
+ 127 "                    current_map.insert((d.name.clone(), false), c);\n"
+ 128 "                },\n"
+ 129 "                Content::File(f) => {\n"
+ 130 "                    current_set.insert((f.name.clone(), true));\n"
+ 131 "                    current_map.insert((f.name.clone(), true), c);\n"
+ 132 "                }\n"
+ 133 "            }\n"
+ 134 "        }\n"
+ 135 "        //\n"
+ 136 "\n"
+ 137 "        // initialise upstream state set\n"
+ 138 "        let mut upstream_set = HashSet::new();\n"
+ 139 "        let mut upstream_map = HashMap::new();\n"
+ 140 "        for c in &upstream.content {\n"
+ 141 "            match c {\n"
+ 142 "                Content::Directory(d) => {\n"
+ 143 "                    upstream_set.insert((d.name.clone(), false));\n"
+ 144 "                    upstream_map.insert((d.name.clone(), false), c);\n"
+ 145 "                },\n"
+ 146 "                Content::File(f) => {\n"
+ 147 "                    upstream_set.insert((f.name.clone(), true));\n"
+ 148 "                    upstream_map.insert((f.name.clone(), true), c);\n"
+ 149 "                }\n"
+ 150 "            }\n"
+ 151 "        }\n"
+ 152 "        //\n"
+ 153 "\n"
+ 154 "        // use set differences to determine file and directory creation or deletion\n"
+ 155 "        let deleted = upstream_set.difference(&current_set).map(|(n, t)| (n.to_string(), *t)).collect::<Vec<(String, bool)>>();\n"
+ 156 "        let created = current_set.difference(&upstream_set).map(|(n, t)| (n.to_string(), *t)).collect::<Vec<(String, bool)>>();\n"
+ 157 "        //\n"
+ 158 "\n"
+ 159 "        // for all deleted files, log them\n"
+ 160 "        // for all deleted directories, log them and do the same for all children\n"
+ 161 "        let mut container_modifications = vec![];\n"
+ 162 "        let mut modifications = vec![];\n"
+ 163 "        for (dir_name, is_file) in deleted {\n"
+ 164 "            if is_file {\n"
+ 165 "                container_modifications.push(ContainerModification::DeleteFile(path.join(dir_name.clone()).to_string_lossy().to_string()));\n"
+ 166 "            } else {\n"
+ 167 "                let p = path.join(dir_name.clone());\n"
+ 168 "                container_modifications.push(ContainerModification::DeleteDirectory(p.to_string_lossy().to_string()));\n"
+ 169 "                // traverse all children, add them to result as well\n"
+ 170 "                let mut changes = Change::get_change_all(\n"
+ 171 "                    match upstream_map.get(&(dir_name, false)).unwrap() {\n"
+ 172 "                        Content::Directory(deleted_d) => { deleted_d },\n"
+ 173 "                        _ => panic!()\n"
+ 174 "                    },\n"
+ 175 "                    &Directory::new(),\n"
+ 176 "                    &p\n"
+ 177 "                );\n"
+ 178 "                container_modifications.append(&mut changes.container_modifications);\n"
+ 179 "                modifications.append(&mut changes.modifications);\n"
+ 180 "            }\n"
+ 181 "        }\n"
+ 182 "        //\n"
+ 183 "\n"
+ 184 "        // for all created files, log them\n"
+ 185 "        // for all created directories, log them and do the same for all children\n"
+ 186 "        for (dir_name, is_file) in created {\n"
+ 187 "            if is_file {\n"
+ 188 "                let p = path.join(dir_name.clone()).to_string_lossy().to_string();\n"
+ 189 "                container_modifications.push(ContainerModification::CreateFile(p.clone(), dir_name.clone()));\n"
+ 190 "                // Modification::Create here\n"
+ 191 "                modifications.append(&mut Change::get_change(p, &File::new(), match current_map.get(&(dir_name, true)).unwrap() {\n"
+ 192 "                    Content::File(f) => { f },\n"
+ 193 "                    _ => panic!()\n"
+ 194 "                }))\n"
+ 195 "            } else {\n"
+ 196 "                let p = path.join(dir_name.clone());\n"
+ 197 "                container_modifications.push(ContainerModification::CreateDirectory(p.to_string_lossy().to_string(), dir_name.clone()));\n"
+ 198 "\n"
+ 199 "                let mut changes = Change::get_change_all(\n"
+ 200 "                    &Directory::new(),\n"
+ 201 "                    match current_map.get(&(dir_name, false)).unwrap() {\n"
+ 202 "                        Content::Directory(d) => d,\n"
+ 203 "                        _ => panic!()\n"
+ 204 "                    },\n"
+ 205 "                    &p\n"
+ 206 "                );\n"
+ 207 "                container_modifications.append(&mut changes.container_modifications);\n"
+ 208 "                modifications.append(&mut changes.modifications);\n"
+ 209 "            }\n"
+ 210 "        }\n"
+ 211 "\n"
+ 212 "        for content in &current.content {\n"
+ 213 "            match content {\n"
+ 214 "                Content::Directory(directory) => {\n"
+ 215 "                    // get the matching upstream directory\n"
+ 216 "                    // if it doesnt exist, that means the content is new and can be ignored\n"
+ 217 "                    // we ignore it because we have already logged it in the section above\n"
+ 218 "                    let p = path.join(directory.name.clone());\n"
+ 219 "                    let upstream_directory = match upstream_map.get(&(directory.name.clone(), false)) {\n"
+ 220 "                        Some(u) => {\n"
+ 221 "                            match u {\n"
+ 222 "                                Content::Directory(u_d) => { u_d },\n"
+ 223 "                                _ => panic!()\n"
+ 224 "                            }\n"
+ 225 "                        },\n"
+ 226 "                        _ => { continue; }\n"
+ 227 "                    };\n"
+ 228 "                    //\n"
+ 229 "\n"
+ 230 "                    let mut changes = Change::get_change_all(\n"
+ 231 "                        upstream_directory,\n"
+ 232 "                        directory,\n"
+ 233 "                        &p\n"
+ 234 "                    );\n"
+ 235 "                    container_modifications.append(&mut changes.container_modifications);\n"
+ 236 "                    modifications.append(&mut changes.modifications);\n"
+ 237 "                },\n"
+ 238 "                Content::File(f) => {\n"
+ 239 "                    let upstream_file = match upstream_map.get(&(f.name.clone(), true)) \n"
+ 240 "                    {\n"
+ 241 "                        Some(c) => match c {\n"
+ 242 "                            Content::File(f) => f,\n"
+ 243 "                            _ => panic!()\n"
+ 244 "                        },\n"
+ 245 "                        None => { continue; }\n"
+ 246 "                    };\n"
+ 247 "\n"
+ 248 "                    modifications.append(&mut Change::get_change(path.join(f.name.clone()).to_string_lossy().to_string(), &upstream_file, &f));\n"
+ 249 "                }\n"
+ 250 "            }\n"
+ 251 "        }\n"
+ 252 "\n"
+ 253 "        Change {\n"
+ 254 "            container_modifications,\n"
+ 255 "            modifications\n"
+ 256 "        }\n"
+ 257 "    }\n"
+ 258 "}\n"
+ 259 "\n"
+ 260 "#[derive(Debug, Clone)]\n"
+ 261 "pub enum Modification {\n"
+ 262 "    // creation/deletion of lines in files\n"
+ 263 "    Create(\n"
+ 264 "        String, // path\n"
+ 265 "        String, // file name\n"
+ 266 "        usize, // line\n"
+ 267 "        String // text\n"
+ 268 "    ),\n"
+ 269 "    Delete(\n"
+ 270 "        String, // path\n"
+ 271 "        String, // file name\n"
+ 272 "        usize // line\n"
+ 273 "    )\n"
+ 274 "}\n"
+ 275 "\n"
+ 276 "#[derive(Debug)]\n"
+ 277 "pub enum ContainerModification {\n"
+ 278 "    // creation/deletion of files & folders\n"
+ 279 "    // TODO : change so only path needed\n"
+ 280 "    CreateDirectory(\n"
+ 281 "        String, // path\n"
+ 282 "        String // name\n"
+ 283 "    ),\n"
+ 284 "    DeleteDirectory(\n"
+ 285 "        String // path\n"
+ 286 "    ),\n"
+ 287 "\n"
+ 288 "    CreateFile(\n"
+ 289 "        String, // path\n"
+ 290 "        String // name\n"
+ 291 "    ),\n"
+ 292 "    DeleteFile(\n"
+ 293 "        String, // path\n"
+ 294 "    )\n"
+ 295 "}\n"
| "./src/relic.rs"
+ 0 "use std::{fs, path::Path};\n"
+ 1 "\n"
+ 2 "use crate::state::State;\n"
+ 3 "\n"
+ 4 "#[derive(Debug)]\n"
+ 5 "pub struct Relic {\n"
+ 6 "    // holds\n"
+ 7 "    //      history.changes\n"
+ 8 "    //      now.changes\n"
+ 9 "    //      root\n"
+ 10 "    //      upstream\n"
+ 11 "    pub upstream: State\n"
+ 12 "}\n"
+ 13 "impl Relic {\n"
+ 14 "    pub fn empty() -> Relic {\n"
+ 15 "        Relic {\n"
+ 16 "            upstream: State::empty()\n"
+ 17 "        }\n"
+ 18 "    }\n"
+ 19 "}\n"
| "./src/state.rs"
+ 0 "use std::{collections::HashSet, fs, path::Path};\n"
+ 1 "use serde::{Deserialize, Serialize};\n"
+ 2 "\n"
+ 3 "use crate::{change::Change, commit::Commit, content::{Content, Directory, File}, error::RelicError, ignore::IgnoreSet};\n"
+ 4 "\n"
+ 5 "#[derive(Debug, Serialize, Deserialize)]\n"
+ 6 "pub struct State {\n"
+ 7 "    pub current: Directory,\n"
+ 8 "    pub upstream: Directory,\n"
+ 9 "    pub path: String\n"
+ 10 "}\n"
+ 11 "\n"
+ 12 "impl State {\n"
+ 13 "    pub fn empty() -> State {\n"
+ 14 "        State {\n"
+ 15 "            current: Directory {\n"
+ 16 "                name: \"\".to_string(),\n"
+ 17 "                content: vec![]\n"
+ 18 "            },\n"
+ 19 "            upstream: Directory {\n"
+ 20 "                name: \"\".to_string(),\n"
+ 21 "                content: vec![]\n"
+ 22 "            },\n"
+ 23 "            path: \"\".to_string()\n"
+ 24 "        }\n"
+ 25 "    }\n"
+ 26 "\n"
+ 27 "    pub fn create(path: String, ignore_set: &IgnoreSet) -> Result<State, RelicError> {\n"
+ 28 "        let current = match State::content_at(&path, &path, ignore_set)? {\n"
+ 29 "            Content::Directory(d) => d,\n"
+ 30 "            _ => return Err(RelicError::ConfigurationIncorrect)\n"
+ 31 "        };\n"
+ 32 "\n"
+ 33 "        let upstream = match fs::read_to_string(\".relic/upstream\") {\n"
+ 34 "            Ok(data) => {\n"
+ 35 "                match Directory::deserialise(data) {\n"
+ 36 "                    Some(d) => d,\n"
+ 37 "                    None => return Err(RelicError::ConfigurationIncorrect)\n"
+ 38 "                }\n"
+ 39 "            },\n"
+ 40 "            Err(_) => return Err(RelicError::FileCantOpen)\n"
+ 41 "        };\n"
+ 42 "\n"
+ 43 "        Ok(State {\n"
+ 44 "            current,\n"
+ 45 "            upstream,\n"
+ 46 "            path\n"
+ 47 "        })\n"
+ 48 "    }\n"
+ 49 "\n"
+ 50 "    pub fn content_at(file_name: &String, root_path: &String, ignore_set: &IgnoreSet) -> Result<Content, RelicError> {\n"
+ 51 "        // get all files at path\n"
+ 52 "        let paths = match fs::read_dir(format!(\"./{}\", root_path.clone())) {\n"
+ 53 "            Ok(r) => r,\n"
+ 54 "            Err(e) => {\n"
+ 55 "                println!(\"state.rs (content_at) get all dirs : {root_path} : {e:?}\");\n"
+ 56 "                return Err(RelicError::FileCantOpen);\n"
+ 57 "            }\n"
+ 58 "        };\n"
+ 59 "\n"
+ 60 "        let mut directory_contents = vec![];\n"
+ 61 "\n"
+ 62 "        // iterate through them all\n"
+ 63 "        for path in paths {\n"
+ 64 "            match path {\n"
+ 65 "                Ok(p) => {\n"
+ 66 "                    let file_type = p.file_type().unwrap();\n"
+ 67 "                    let file_name = p.file_name().into_string().unwrap();\n"
+ 68 "                    let file_path = p.path().to_string_lossy().to_string();\n"
+ 69 "\n"
+ 70 "                    if file_name.starts_with(\".\") {\n"
+ 71 "                        continue;\n"
+ 72 "                    }\n"
+ 73 "\n"
+ 74 "                    if file_type.is_dir() {\n"
+ 75 "                        if ignore_set.dir_ignore.contains(&file_name) {\n"
+ 76 "                            continue;\n"
+ 77 "                        }\n"
+ 78 "\n"
+ 79 "                        match State::content_at(&file_name, &file_path, ignore_set) {\n"
+ 80 "                            Ok(c) => {\n"
+ 81 "                                directory_contents.push(c);\n"
+ 82 "                            },\n"
+ 83 "                            Err(e) => {\n"
+ 84 "                                println!(\"state.rs (content_at) subtraverse : {e:?}\");\n"
+ 85 "                            }\n"
+ 86 "                        }\n"
+ 87 "                    } else if file_type.is_file() {\n"
+ 88 "                        if ignore_set.file_ignore.contains(&file_name) {\n"
+ 89 "                            continue;\n"
+ 90 "                        }\n"
+ 91 "\n"
+ 92 "                        match File::create(file_name, file_path) {\n"
+ 93 "                            Ok(f) => {\n"
+ 94 "                                directory_contents.push(Content::File(f));\n"
+ 95 "                            },\n"
+ 96 "                            _ => {}\n"
+ 97 "                        }\n"
+ 98 "                    } else if file_type.is_symlink() {\n"
+ 99 "                        // TODO : decide what to do here\n"
+ 100 "                        if ignore_set.file_ignore.contains(&file_name) {\n"
+ 101 "                            continue;\n"
+ 102 "                        }\n"
+ 103 "                    }\n"
+ 104 "                },\n"
+ 105 "                Err(e) => {\n"
+ 106 "                    println!(\"state.rs (content_at) read_dir : {e:?}\");\n"
+ 107 "                }\n"
+ 108 "            }\n"
+ 109 "        }\n"
+ 110 "\n"
+ 111 "        Ok(Content::Directory(Directory {\n"
+ 112 "            name: file_name.clone(),\n"
+ 113 "            content: directory_contents\n"
+ 114 "        }))\n"
+ 115 "    }\n"
+ 116 "\n"
+ 117 "    pub fn serialise_state(self: &State) -> String {\n"
+ 118 "        serde_json::to_string(self).unwrap()\n"
+ 119 "    }\n"
+ 120 "    \n"
+ 121 "    pub fn deserialise_state(s: String) -> Option<State> {\n"
+ 122 "        match serde_json::from_str(&s) {\n"
+ 123 "            Ok(s) => Some(s),\n"
+ 124 "            Err(_) => None\n"
+ 125 "        }\n"
+ 126 "    }\n"
+ 127 "\n"
+ 128 "    pub fn get_changes(&self) -> Change {\n"
+ 129 "        Change::get_change_all(&self.upstream, &self.current, Path::new(&self.path))\n"
+ 130 "    }\n"
+ 131 "\n"
+ 132 "    // #region upstream\n"
+ 133 "    pub fn update_upstream(&self, to_update: HashSet<String>) {\n"
+ 134 "        // replaces upstream with current directory\n"
+ 135 "        // TODO : implement to_update\n"
+ 136 "\n"
+ 137 "        let _ = fs::write(\".relic/upstream\", self.current.serialise());\n"
+ 138 "    }\n"
+ 139 "    // #endregion\n"
+ 140 "\n"
+ 141 "    // #region pending\n"
+ 142 "    pub fn pending_add(&self, commit: Commit) {\n"
+ 143 "        // println!(\"adding : {}\\ncontents : {}\", commit.message, commit.serialise());\n"
+ 144 "        let _ = fs::write(format!(\".relic/pending/{}.diff\", commit.timestamp), commit.serialise());\n"
+ 145 "    }\n"
+ 146 "    // #endregion\n"
+ 147 "}\n"
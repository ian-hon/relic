= LOCAL 1758903530318 "Unhardcoded%20several%20defaults" "" no_one
+ F . .relic_ignore
=
| . .relic_ignore
+ 0 "-- Added by Relic: Automatically ignore all git content"
+ 1 ".git/"
+ 2 ".gitignore"
+ 4 "target/"
+ 5 "Cargo.lock"
| .%2Fsrc%2Fcommands init.rs
- 4 "use crate::core::{content_set, objects::data::Upstream, paths, state, State};"
+ 4 "use crate::core::{content_set, objects::data::Upstream, paths, RelicInfo, State};"
- 23 "    let _ = fs::write(paths::RELIC_PATH_INFO, state::DEFAULT_INFO);"
+ 23 "    let _ = fs::write(paths::RELIC_PATH_INFO, RelicInfo::default().serialise());"
| .%2Fsrc%2Fcore commit.rs
- 15 "    pub fn hash(&self) -> String {"
- 16 "        sha256::digest(self.serialise())"
- 17 "    }"
- 18 ""
| .%2Fsrc%2Fcore relic_info.rs
- 4 "use crate::{core::paths::RELIC_PATH_INFO, error::RelicError};"
+ 4 "use crate::{"
+ 5 "    core::{paths::RELIC_PATH_INFO, state},"
+ 6 "    error::RelicError,"
+ 7 "};"
+ 22 "    pub fn default() -> RelicInfo {"
+ 23 "        RelicInfo {"
+ 24 "            remote: \"\".to_string(),"
+ 25 "            branch: state::DEFAULT_BRANCH.to_string(),"
+ 26 "        }"
+ 27 "    }"
+ 28 ""
+ 40 ""
+ 41 "    pub fn serialise(&self) -> String {"
+ 42 "        serde_json::to_string(self).unwrap()"
+ 43 "    }"
| .%2Fsrc%2Fcore state.rs
- 12 "        objects::data::upstream::{self, Upstream},"
+ 12 "        objects::data::upstream::Upstream,"
- 19 "// TODO: throw these into constructors, not hard coded"
- 20 "pub const DEFAULT_INFO: &str = r#\"{"
- 21 "    \"remote\":\"\","
- 22 "    \"branch\":\"main\""
- 23 "}\"#;"
+ 19 "pub const DEFAULT_BRANCH: &str = \"main\";"
- 177 "    }"
- 178 ""
- 179 "    pub fn serialise_state(self: &State) -> String {"
- 180 "        serde_json::to_string(self).unwrap()"
- 181 "    }"
- 182 ""
- 183 "    pub fn deserialise_state(s: String) -> Option<State> {"
- 184 "        match serde_json::from_str(&s) {"
- 185 "            Ok(s) => Some(s),"
- 186 "            Err(_) => None,"
- 187 "        }"
| .%2Fsrc%2Fcore%2Fobjects%2Fdata content_set.rs
- 26 ""
- 27 "    pub fn as_set(&self) -> HashSet<String> {"
- 28 "        HashSet::new()"
- 29 "    }"
| .%2Fsrc%2Fcore%2Fobjects%2Fdata tree.rs
- 29 "    pub fn get_hash(&self) -> String {"
- 30 "        sha256::digest(serde_json::to_string(&self).unwrap())"
- 31 "    }"
+ 29 "    // pub fn get_hash(&self) -> String {"
+ 30 "    //     sha256::digest(serde_json::to_string(&self).unwrap())"
+ 31 "    // }"
- 33 "    pub fn deserialise(s: String) -> Option<Tree> {"
- 34 "        match serde_json::from_str(&s) {"
- 35 "            Ok(d) => Some(d),"
- 36 "            _ => None,"
- 37 "        }"
- 38 "    }"
+ 33 "    // pub fn deserialise(s: String) -> Option<Tree> {"
+ 34 "    //     match serde_json::from_str(&s) {"
+ 35 "    //         Ok(d) => Some(d),"
+ 36 "    //         _ => None,"
+ 37 "    //     }"
+ 38 "    // }"
- 40 "    pub fn deserialise_content(s: String) -> Option<Vec<Content>> {"
- 41 "        // used only for init"
- 42 "        // same as deserialise, but only content, no name or path"
- 43 "        match serde_json::from_str(&s) {"
- 44 "            Ok(d) => Some(d),"
- 45 "            _ => None,"
- 46 "        }"
- 47 "    }"
+ 40 "    // pub fn deserialise_content(s: String) -> Option<Vec<Content>> {"
+ 41 "    //     // used only for init"
+ 42 "    //     // same as deserialise, but only content, no name or path"
+ 43 "    //     match serde_json::from_str(&s) {"
+ 44 "    //         Ok(d) => Some(d),"
+ 45 "    //         _ => None,"
+ 46 "    //     }"
+ 47 "    // }"
- 49 "    pub fn serialise(&self) -> String {"
- 50 "        serde_json::to_string_pretty(&self).unwrap()"
- 51 "    }"
+ 49 "    // pub fn serialise(&self) -> String {"
+ 50 "    //     serde_json::to_string_pretty(&self).unwrap()"
+ 51 "    // }"
| .%2Fsrc%2Fcore%2Fobjects%2Fmodifications%2Fchange mod.rs
- 17 "    pub fn get_hash(&self) -> String {"
- 18 "        sha256::digest(self.serialise_changes())"
- 19 "    }"
- 20 ""
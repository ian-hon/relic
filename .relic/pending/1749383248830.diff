= LOCAL 1749383248830 "usage%20of%20path%20constants" "" no_one
+ F .%2Fsrc relic_info.rs
+ F .%2Fsrc paths.rs
=
| .%2Fsrc commit.rs
+ 7 "    paths::RELIC_PATH_TRACKED,"
- 105 "        fs::read_to_string(\"./.relic/tracked\")"
+ 106 "        fs::read_to_string(format!(\"./{RELIC_PATH_TRACKED}\"))"
- 125 "        \"./.relic/tracked\","
+ 126 "        format!(\"./{RELIC_PATH_TRACKED}\"),"
- 138 "        fs::read_to_string(\"./.relic/tracked\")"
+ 139 "        fs::read_to_string(format!(\"./{RELIC_PATH_TRACKED}\"))"
- 180 "        \"./.relic/tracked\","
+ 181 "        format!(\"./{RELIC_PATH_TRACKED}\"),"
| .%2Fsrc error.rs
+ 7 "    RelicInfo(Box<RelicError>),"
| .%2Fsrc main.rs
+ 3 "mod paths;"
+ 4 ""
+ 13 "mod relic_info;"
- 166 "        ),"
- 167 "        ("
- 168 "            |s, _| {"
- 169 "                s.upstream.apply_changes(s.get_changes());"
- 170 "            },"
- 171 "            Command::new(\"test\").about(\"test\"),"
+ 175 "        ),"
+ 176 "        ("
+ 177 "            |s, _| {"
+ 178 "                println!(\"{:?}\", s.info);"
+ 179 "            },"
+ 180 "            Command::new(\"test\").about(\"this is here for debug purposes\")"
- 222 "                println!(\"No Relic repository found in current directory. Consider executing 'relic init' or 'relic clone'.\");"
+ 225 "                println!(\"No valid Relic repository found in current directory. Consider executing 'relic init' or 'relic clone'.\");"
| .%2Fsrc paths.rs
+ 0 "pub const RELIC_PATH_PARENT: &str = \".relic\";"
+ 1 "pub const RELIC_PATH_HISTORY: &str = \".relic/history\";"
+ 2 "pub const RELIC_PATH_PENDING: &str = \".relic/pending\";"
+ 3 ""
+ 4 "pub const RELIC_PATH_ROOT: &str = \".relic/root\";"
+ 5 "pub const RELIC_PATH_INFO: &str = \".relic/info.json\";"
+ 6 "pub const RELIC_PATH_TRACKED: &str = \".relic/tracked\";"
+ 7 "pub const RELIC_PATH_UPSTREAM: &str = \".relic/upstream\";"
+ 8 ""
+ 9 "pub const RELIC_PATH_IGNORE: &str = \".relic_ignore\";"
| .%2Fsrc relic_info.rs
+ 0 "use std::fs;"
+ 1 ""
+ 2 "use serde::{Deserialize, Serialize};"
+ 3 ""
+ 4 "use crate::{error::RelicError, paths::RELIC_PATH_INFO};"
+ 5 ""
+ 6 "#[derive(Serialize, Deserialize, Clone, Debug)]"
+ 7 "pub struct RelicInfo {"
+ 8 "    pub remote: String,"
+ 9 "    pub branch: String,"
+ 10 "}"
+ 11 "impl RelicInfo {"
+ 12 "    pub fn empty() -> RelicInfo {"
+ 13 "        RelicInfo {"
+ 14 "            remote: \"\".to_string(),"
+ 15 "            branch: \"\".to_string(),"
+ 16 "        }"
+ 17 "    }"
+ 18 ""
+ 19 "    pub fn initialise() -> Result<RelicInfo, RelicError> {"
+ 20 "        if let Ok(t) = fs::read_to_string(format!(\"./{RELIC_PATH_INFO}\")) {"
+ 21 "            if let Ok(d) = serde_json::from_str::<RelicInfo>(&t) {"
+ 22 "                return Ok(d);"
+ 23 "            }"
+ 24 "            return Err(RelicError::RelicInfo(Box::new("
+ 25 "                RelicError::ConfigurationIncorrect,"
+ 26 "            )));"
+ 27 "        }"
+ 28 "        Err(RelicError::RelicInfo(Box::new(RelicError::FileCantOpen)))"
+ 29 "    }"
+ 30 "}"
| .%2Fsrc state.rs
+ 14 "    paths::{self, RELIC_PATH_IGNORE, RELIC_PATH_PENDING, RELIC_PATH_TRACKED, RELIC_PATH_UPSTREAM},"
+ 15 "    relic_info::RelicInfo,"
+ 18 "const DEFAULT_INFO: &str = r#\"{"
+ 19 "    \"remote\":\"\","
+ 20 "    \"branch\":\"main\""
+ 21 "}\"#;"
+ 22 "const DEFAULT_UPSTREAM: &str = r#\"{"
+ 23 "    \"path\": \"\","
+ 24 "    \"name\": \"\","
+ 25 "    \"content\": []"
+ 26 "}\"#;"
+ 27 ""
+ 30 "    pub info: RelicInfo,"
+ 43 "            info: RelicInfo::empty(),"
+ 53 "        let info = match RelicInfo::initialise() {"
+ 54 "            Ok(r) => r,"
+ 55 "            Err(e) => return Err(e),"
+ 56 "        };"
+ 57 ""
- 40 "            IgnoreSet::create(fs::read_to_string(\".relic_ignore\").unwrap_or(\"\".to_string()));"
+ 59 "            IgnoreSet::create(fs::read_to_string(RELIC_PATH_IGNORE).unwrap_or(\"\".to_string()));"
- 48 "        let upstream = match fs::read_to_string(\".relic/upstream\") {"
+ 67 "        let upstream = match fs::read_to_string(RELIC_PATH_UPSTREAM) {"
- 57 "        let mut track_set: ContentSet = match fs::read_to_string(\".relic/tracked\") {"
+ 76 "        let mut track_set: ContentSet = match fs::read_to_string(RELIC_PATH_TRACKED) {"
+ 101 "            info,"
- 195 "        let _ = fs::write(\".relic/upstream\", self.upstream.serialise());"
+ 215 "        let _ = fs::write(RELIC_PATH_UPSTREAM, self.upstream.serialise());"
- 204 "            format!(\".relic/pending/{}.diff\", commit.timestamp),"
+ 224 "            format!(\"{RELIC_PATH_PENDING}/{}.diff\", commit.timestamp),"
- 210 "        let directories = if let Ok(d) = fs::read_dir(\".relic/pending\") {"
+ 230 "        let directories = if let Ok(d) = fs::read_dir(RELIC_PATH_PENDING) {"
- 252 "    let _ = fs::create_dir(\".relic\");"
- 253 "    let _ = fs::create_dir(\".relic/history\");"
- 254 "    let _ = fs::create_dir(\".relic/pending\");"
- 255 "    let _ = fs::write(\".relic/root\", \"\");"
- 256 "    let _ = fs::write(\".relic/tracked\", \"\");"
- 257 "    let _ = fs::write(\".relic/pending\", \"\");"
- 258 "    let _ = fs::write("
- 259 "        \".relic/upstream\","
- 260 "        r#\"{"
- 261 "    \"path\": \"\","
- 262 "    \"name\": \"\","
- 263 "    \"content\": []"
- 264 "}\"#,"
- 265 "    );"
+ 272 "    let _ = fs::create_dir(paths::RELIC_PATH_PARENT);"
+ 273 "    let _ = fs::create_dir(paths::RELIC_PATH_HISTORY);"
+ 274 "    let _ = fs::create_dir(paths::RELIC_PATH_PENDING);"
+ 275 "    let _ = fs::write(paths::RELIC_PATH_INFO, DEFAULT_INFO);"
+ 276 "    let _ = fs::write(paths::RELIC_PATH_ROOT, \"\");"
+ 277 "    let _ = fs::write(paths::RELIC_PATH_TRACKED, \"\");"
+ 278 "    let _ = fs::write(paths::RELIC_PATH_UPSTREAM, DEFAULT_UPSTREAM);"
- 267 "    let _ = fs::write(\".relic_ignore\", content_set::DEFAULT_IGNORE);"
+ 280 "    let _ = fs::write(paths::RELIC_PATH_IGNORE, content_set::DEFAULT_IGNORE);"
- 275 "    let _ = fs::remove_dir_all(\".relic\");"
- 276 "    let _ = fs::remove_file(\".relic_ignore\");"
+ 288 "    let _ = fs::remove_dir_all(paths::RELIC_PATH_PARENT);"
+ 289 "    let _ = fs::remove_file(paths::RELIC_PATH_IGNORE);"
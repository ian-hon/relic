= LOCAL 1747196074 "%28WIP%29%20File%20tracking%20implementation" "" no_one
+ F "./ipsum" "ipsum"
- F "./src/ignore.rs"
+ F "./src/content_set.rs" "content_set.rs"
=
| "./src/content_set.rs"
+ 0 "use std::collections::HashSet;\n"
+ 1 "\n"
+ 2 "use serde::{Deserialize, Serialize};\n"
+ 3 "\n"
+ 4 "#[derive(Serialize, Deserialize, Debug)]\n"
+ 5 "pub struct ContentSet {\n"
+ 6 "    pub directories: HashSet<String>,\n"
+ 7 "    pub files: HashSet<String>\n"
+ 8 "}\n"
+ 9 "impl ContentSet {\n"
+ 10 "    pub fn empty() -> ContentSet {\n"
+ 11 "        ContentSet {\n"
+ 12 "            directories: HashSet::new(),\n"
+ 13 "            files: HashSet::new()\n"
+ 14 "        }\n"
+ 15 "    }\n"
+ 16 "\n"
+ 17 "    pub fn as_set(&self) -> HashSet<String> {\n"
+ 18 "\n"
+ 19 "\n"
+ 20 "        HashSet::new()\n"
+ 21 "    }\n"
+ 22 "}\n"
+ 23 "\n"
+ 24 "pub trait IgnoreSet {\n"
+ 25 "    fn create(content: String) -> Self;\n"
+ 26 "}\n"
+ 27 "impl IgnoreSet for ContentSet {\n"
+ 28 "    fn create(content: String) -> ContentSet {\n"
+ 29 "        let mut result = ContentSet {\n"
+ 30 "            directories: HashSet::new(),\n"
+ 31 "            files: HashSet::new()\n"
+ 32 "        };\n"
+ 33 "\n"
+ 34 "        // always ignore the .relic directory\n"
+ 35 "        result.directories.insert(\".relic\".to_string());\n"
+ 36 "\n"
+ 37 "        for line in content.split(\"\\n\") {\n"
+ 38 "            if line.is_empty() {\n"
+ 39 "                continue;\n"
+ 40 "            }\n"
+ 41 "\n"
+ 42 "            // doesnt take into account cases like \n"
+ 43 "            // some_directory// <- double slashes\n"
+ 44 "            if line.ends_with(\"/\") {\n"
+ 45 "                let i = line[0..line.len() - 1].to_string();\n"
+ 46 "                if i.is_empty() {\n"
+ 47 "                    continue;\n"
+ 48 "                }\n"
+ 49 "\n"
+ 50 "                result.directories.insert(i);\n"
+ 51 "            } else {\n"
+ 52 "                result.files.insert(line.to_string());\n"
+ 53 "            }\n"
+ 54 "        }\n"
+ 55 "\n"
+ 56 "        result\n"
+ 57 "    }\n"
+ 58 "}\n"
+ 59 "\n"
+ 60 "pub trait TrackingSet {\n"
+ 61 "    fn deserialise(content: String) -> Self;\n"
+ 62 "}\n"
+ 63 "impl TrackingSet for ContentSet {\n"
+ 64 "    fn deserialise(content: String) -> Self {\n"
+ 65 "        let mut result = ContentSet::empty();\n"
+ 66 "\n"
+ 67 "        for d in content.split(\"\\n\").map(|x| x.to_string()).collect::<Vec<String>>() {\n"
+ 68 "            if d.ends_with(\"/\") {\n"
+ 69 "                // dir\n"
+ 70 "                result.directories.insert(d[..d.len() - 1].to_string());\n"
+ 71 "            } else {\n"
+ 72 "                // file\n"
+ 73 "                result.files.insert(d);\n"
+ 74 "            }\n"
+ 75 "        }\n"
+ 76 "\n"
+ 77 "        result\n"
+ 78 "    }\n"
+ 79 "}\n"
| "./src/commit.rs"
- 0
+ 0 "use std::{collections::HashSet, path::PathBuf};\n"
- 29
+ 29 "pub fn add(state: State, args: &ArgMatches) {\n"
+ 30 "    // let f: HashSet<String> = HashSet::from_iter(args.get_many::<String>(\"FILE\").unwrap().map(|x| x.to_string()).collect::<Vec<String>>());\n"
+ 31 "    let f = args.get_many::<PathBuf>(\"FILE\").unwrap().map(|x| x.clone()).collect::<Vec<PathBuf>>();\n"
+ 33 "    // f.difference(state.ignore_set);\n"
+ 34 "    for p in f {\n"
+ 35 "        println!(\"{p:?} : {}\", p.is_dir());\n"
+ 36 "    }\n"
- 64
+ 70 "    state.update_upstream(&state.track_set);\n"
| "./src/main.rs"
- 1
+ 1 "use std::path::{Path, PathBuf};\n"
- 5
+ 5 "mod content_set;\n"
- 17
+ 17 "use clap::{arg, value_parser, ArgMatches, Command};\n"
- 20
+ 20 "use content_set::ContentSet;\n"
+ 67 "            Command::new(\"init\")\n"
+ 68 "                .about(\"Initialises a Relic repository in the current directory.\")\n"
+ 69 "        )\n"
+ 70 "\n"
+ 71 "        .subcommand(\n"
+ 72 "            Command::new(\"add\")\n"
+ 73 "                .about(\"Adds a file to staging\")\n"
+ 74 "                .arg_required_else_help(true)\n"
+ 75 "                .arg(\n"
+ 76 "                    arg!([FILE]... \"File to add (* for all)\")\n"
+ 77 "                    .required(true)\n"
+ 78 "                    .value_parser(value_parser!(PathBuf))\n"
+ 79 "                )\n"
+ 80 "        )\n"
+ 81 "        .subcommand(\n"
- 74
- 75
- 76
- 77
- 118
- 119
+ 129 "            Command::new(\"staging\")\n"
+ 130 "                .about(\"DEBUG : view all staging changes\")\n"
+ 136 "        // TODO : pass user credentials into commands too\n"
+ 137 "        (\"init\".to_string(), init),\n"
+ 138 "\n"
+ 139 "        (\"add\".to_string(), add),\n"
+ 144 "\n"
+ 148 "\n"
- 138
- 139
- 140
- 141
- 142
+ 155 "        (\"staging\".to_string(), |s, _| {\n"
+ 156 "            println!(\"{}\", s.get_changes().serialise_changes());\n"
- 146
- 147
- 148
- 149
- 150
- 152
- 153
- 154
- 155
- 156
+ 161 "    match State::create(\".\".to_string()) {\n"
| "./src/content.rs"
- 0
+ 0 "use std::{collections::HashSet, fs};\n"
| "./src/state.rs"
- 3
+ 3 "use crate::{change::Change, commit::Commit, content::{Content, Directory, File}, content_set::{ContentSet, IgnoreSet, TrackingSet}, error::RelicError};\n"
- 9
+ 9 "    pub path: String,\n"
+ 10 "    pub track_set: ContentSet,\n"
+ 11 "    pub ignore_set: ContentSet\n"
- 23
+ 25 "            path: \"\".to_string(),\n"
+ 26 "            track_set: ContentSet::empty(),\n"
+ 27 "            ignore_set: ContentSet::empty()\n"
- 27
- 28
+ 31 "    pub fn create(path: String) -> Result<State, RelicError> {\n"
+ 32 "        let ignore_set = IgnoreSet::create(fs::read_to_string(\".relic_ignore\").unwrap_or(\"\".to_string()));\n"
+ 33 "\n"
+ 34 "        let current = match State::content_at(&path, &path, &ignore_set)? {\n"
+ 49 "        let mut track_set: ContentSet = match fs::read_to_string(\".relic/tracked\") {\n"
+ 50 "            Ok(data) => TrackingSet::deserialise(data),\n"
+ 51 "            Err(_) => return Err(RelicError::ConfigurationIncorrect)\n"
+ 52 "        };\n"
+ 53 "\n"
+ 54 "        track_set.directories = HashSet::from_iter(track_set.directories.difference(&ignore_set.directories).map(|x| x.to_string()));\n"
+ 55 "        track_set.files = HashSet::from_iter(track_set.files.difference(&ignore_set.files).map(|x| x.to_string()));\n"
+ 56 "\n"
- 46
+ 60 "            path,\n"
+ 61 "            track_set,\n"
+ 62 "            ignore_set\n"
- 50
+ 66 "    pub fn content_at(file_name: &String, root_path: &String, ignore_set: &ContentSet) -> Result<Content, RelicError> {\n"
- 75
+ 91 "                        if ignore_set.directories.contains(&file_name) {\n"
- 88
+ 104 "                        if ignore_set.files.contains(&file_name) {\n"
- 100
+ 116 "                        if ignore_set.files.contains(&file_name) {\n"
- 133
+ 149 "    pub fn update_upstream(&self, to_update: &ContentSet) {\n"
+ 153 "        \n"
+ 154 "\n"
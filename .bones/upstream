{"current":{"name":".","content":[{"File":{"name":"Cargo.toml","content":"[package]\nname = \"barebones-vcs\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nsha256 = \"1.5.0\"\n\nstrum = \"0.26.3\"\nstrum_macros = \"0.26.3\"\n\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\ndotenv = \"0.15.0\"\n\nsimilar = \"2.7.0\""}},{"File":{"name":"Cargo.lock","content":"# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\nversion = 3\n\n[[package]]\nname = \"addr2line\"\nversion = \"0.24.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1\"\ndependencies = [\n \"gimli\",\n]\n\n[[package]]\nname = \"adler2\"\nversion = \"2.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"512761e0bb2578dd7380c6baaa0f4ce03e84f95e960231d1dec8bf4d7d6e2627\"\n\n[[package]]\nname = \"async-trait\"\nversion = \"0.1.88\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e539d3fca749fcee5236ab05e93a52867dd549cc157c8cb7f99595f3cedffdb5\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn\",\n]\n\n[[package]]\nname = \"backtrace\"\nversion = \"0.3.74\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8d82cb332cdfaed17ae235a638438ac4d4839913cc2af585c3c6746e8f8bee1a\"\ndependencies = [\n \"addr2line\",\n \"cfg-if\",\n \"libc\",\n \"miniz_oxide\",\n \"object\",\n \"rustc-demangle\",\n \"windows-targets\",\n]\n\n[[package]]\nname = \"barebones-vcs\"\nversion = \"0.1.0\"\ndependencies = [\n \"dotenv\",\n \"serde\",\n \"serde_json\",\n \"sha256\",\n \"similar\",\n \"strum\",\n \"strum_macros\",\n]\n\n[[package]]\nname = \"block-buffer\"\nversion = \"0.10.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71\"\ndependencies = [\n \"generic-array\",\n]\n\n[[package]]\nname = \"bytes\"\nversion = \"1.10.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a\"\n\n[[package]]\nname = \"cfg-if\"\nversion = \"1.0.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n\n[[package]]\nname = \"cpufeatures\"\nversion = \"0.2.17\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280\"\ndependencies = [\n \"libc\",\n]\n\n[[package]]\nname = \"crypto-common\"\nversion = \"0.1.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3\"\ndependencies = [\n \"generic-array\",\n \"typenum\",\n]\n\n[[package]]\nname = \"digest\"\nversion = \"0.10.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292\"\ndependencies = [\n \"block-buffer\",\n \"crypto-common\",\n]\n\n[[package]]\nname = \"dotenv\"\nversion = \"0.15.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"77c90badedccf4105eca100756a0b1289e191f6fcbdadd3cee1d2f614f97da8f\"\n\n[[package]]\nname = \"generic-array\"\nversion = \"0.14.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a\"\ndependencies = [\n \"typenum\",\n \"version_check\",\n]\n\n[[package]]\nname = \"gimli\"\nversion = \"0.31.1\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f\"\n\n[[package]]\nname = \"heck\"\nversion = \"0.5.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea\"\n\n[[package]]\nname = \"hex\"\nversion = \"0.4.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70\"\n\n[[package]]\nname = \"itoa\"\nversion = \"1.0.15\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c\"\n\n[[package]]\nname = \"libc\"\nversion = \"0.2.172\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"d750af042f7ef4f724306de029d18836c26c1765a54a6a3f094cbd23a7267ffa\"\n\n[[package]]\nname = \"memchr\"\nversion = \"2.7.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"78ca9ab1a0babb1e7d5695e3530886289c18cf2f87ec19a575a0abdce112e3a3\"\n\n[[package]]\nname = \"miniz_oxide\"\nversion = \"0.8.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3be647b768db090acb35d5ec5db2b0e1f1de11133ca123b9eacf5137868f892a\"\ndependencies = [\n \"adler2\",\n]\n\n[[package]]\nname = \"object\"\nversion = \"0.36.7\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87\"\ndependencies = [\n \"memchr\",\n]\n\n[[package]]\nname = \"pin-project-lite\"\nversion = \"0.2.16\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b\"\n\n[[package]]\nname = \"proc-macro2\"\nversion = \"1.0.95\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778\"\ndependencies = [\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"quote\"\nversion = \"1.0.40\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d\"\ndependencies = [\n \"proc-macro2\",\n]\n\n[[package]]\nname = \"rustc-demangle\"\nversion = \"0.1.24\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"719b953e2095829ee67db738b3bfa9fa368c94900df327b3f07fe6e794d2fe1f\"\n\n[[package]]\nname = \"rustversion\"\nversion = \"1.0.20\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"eded382c5f5f786b989652c49544c4877d9f015cc22e145a5ea8ea66c2921cd2\"\n\n[[package]]\nname = \"ryu\"\nversion = \"1.0.20\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f\"\n\n[[package]]\nname = \"serde\"\nversion = \"1.0.219\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6\"\ndependencies = [\n \"serde_derive\",\n]\n\n[[package]]\nname = \"serde_derive\"\nversion = \"1.0.219\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"syn\",\n]\n\n[[package]]\nname = \"serde_json\"\nversion = \"1.0.140\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"20068b6e96dc6c9bd23e01df8827e6c7e1f2fddd43c21810382803c136b99373\"\ndependencies = [\n \"itoa\",\n \"memchr\",\n \"ryu\",\n \"serde\",\n]\n\n[[package]]\nname = \"sha2\"\nversion = \"0.10.8\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"793db75ad2bcafc3ffa7c68b215fee268f537982cd901d132f89c6343f3a3dc8\"\ndependencies = [\n \"cfg-if\",\n \"cpufeatures\",\n \"digest\",\n]\n\n[[package]]\nname = \"sha256\"\nversion = \"1.6.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"f880fc8562bdeb709793f00eb42a2ad0e672c4f883bbe59122b926eca935c8f6\"\ndependencies = [\n \"async-trait\",\n \"bytes\",\n \"hex\",\n \"sha2\",\n \"tokio\",\n]\n\n[[package]]\nname = \"similar\"\nversion = \"2.7.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"bbbb5d9659141646ae647b42fe094daf6c6192d1620870b449d9557f748b2daa\"\n\n[[package]]\nname = \"strum\"\nversion = \"0.26.3\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8fec0f0aef304996cf250b31b5a10dee7980c85da9d759361292b8bca5a18f06\"\n\n[[package]]\nname = \"strum_macros\"\nversion = \"0.26.4\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"4c6bee85a5a24955dc440386795aa378cd9cf82acd5f764469152d2270e581be\"\ndependencies = [\n \"heck\",\n \"proc-macro2\",\n \"quote\",\n \"rustversion\",\n \"syn\",\n]\n\n[[package]]\nname = \"syn\"\nversion = \"2.0.100\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"b09a44accad81e1ba1cd74a32461ba89dee89095ba17b32f5d03683b1b1fc2a0\"\ndependencies = [\n \"proc-macro2\",\n \"quote\",\n \"unicode-ident\",\n]\n\n[[package]]\nname = \"tokio\"\nversion = \"1.44.2\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"e6b88822cbe49de4185e3a4cbf8321dd487cf5fe0c5c65695fef6346371e9c48\"\ndependencies = [\n \"backtrace\",\n \"bytes\",\n \"pin-project-lite\",\n]\n\n[[package]]\nname = \"typenum\"\nversion = \"1.18.0\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"1dccffe3ce07af9386bfd29e80c0ab1a8205a2fc34e4bcd40364df902cfa8f3f\"\n\n[[package]]\nname = \"unicode-ident\"\nversion = \"1.0.18\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512\"\n\n[[package]]\nname = \"version_check\"\nversion = \"0.9.5\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a\"\n\n[[package]]\nname = \"windows-targets\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973\"\ndependencies = [\n \"windows_aarch64_gnullvm\",\n \"windows_aarch64_msvc\",\n \"windows_i686_gnu\",\n \"windows_i686_gnullvm\",\n \"windows_i686_msvc\",\n \"windows_x86_64_gnu\",\n \"windows_x86_64_gnullvm\",\n \"windows_x86_64_msvc\",\n]\n\n[[package]]\nname = \"windows_aarch64_gnullvm\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3\"\n\n[[package]]\nname = \"windows_aarch64_msvc\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469\"\n\n[[package]]\nname = \"windows_i686_gnu\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b\"\n\n[[package]]\nname = \"windows_i686_gnullvm\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66\"\n\n[[package]]\nname = \"windows_i686_msvc\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66\"\n\n[[package]]\nname = \"windows_x86_64_gnu\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78\"\n\n[[package]]\nname = \"windows_x86_64_gnullvm\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d\"\n\n[[package]]\nname = \"windows_x86_64_msvc\"\nversion = \"0.52.6\"\nsource = \"registry+https://github.com/rust-lang/crates.io-index\"\nchecksum = \"589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec\"\n"}},{"Directory":{"name":"lorem","content":[{"Directory":{"name":"ipsum","content":[{"File":{"name":"saturn","content":""}},{"File":{"name":"jupiter","content":""}},{"Directory":{"name":"dolor","content":[{"File":{"name":"titan","content":""}}]}},{"File":{"name":"something_else","content":""}}]}},{"File":{"name":"pluto","content":""}},{"File":{"name":"earth","content":"lorem\nipsum\ndolor\nsit\namet"}},{"File":{"name":"mars","content":""}}]}},{"Directory":{"name":"src","content":[{"File":{"name":"branch.rs","content":"use crate::state::State;\n\npub fn branch(state: State, args: Vec<String>) {\n\n}"}},{"File":{"name":"stash.rs","content":"use crate::state::State;\n\npub fn stash(state: State, args: Vec<String>) {\n\n}\n\npub fn restore(state: State, args: Vec<String>) {\n\n}"}},{"File":{"name":"commit.rs","content":"use crate::state::State;\n\npub fn add(state: State, args: Vec<String>) {\n\n}\n\npub fn commit(state: State, args: Vec<String>) {\n\n}\n\npub fn push(state: State, args: Vec<String>) {\n\n}\n\npub fn pull(state: State, args: Vec<String>) {\n\n}\n\npub fn fetch(state: State, args: Vec<String>) {\n\n}\n\npub fn cherry(state: State, args: Vec<String>) {\n    \n}\n\npub fn rollback(state: State, args: Vec<String>) {\n\n}"}},{"File":{"name":"error.rs","content":"use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Serialize, Deserialize)]\npub enum BonesError {\n    FileCantOpen,\n    IgnoredFile,\n    ConfigurationIncorrect\n}"}},{"File":{"name":"change.rs","content":"use std::{collections::{HashMap, HashSet}, path::Path};\n\nuse similar::{ChangeTag, TextDiff};\nuse strum_macros::Display;\n\nuse crate::{content::{Content, Directory, File}, state::State};\n\n#[derive(Debug)]\npub struct Change {\n    pub container_modifications: Vec<ContainerModification>,\n    pub modifications: Vec<Modification>\n}\nimpl Change {\n    pub fn serialise_changes() -> String {\n        \"\".to_string()\n    }\n    \n    pub fn deserialise_changes() -> String {\n        \"\".to_string()\n    }\n\n    pub fn get_change(path: String, upstream_file: &File, current_file: &File) -> Vec<Modification> {\n        // https://blog.jcoglan.com/2017/02/15/the-myers-diff-algorithm-part-2/\n        // for our change algorithm, we will be using myers diff algorithm\n        // basically a shortest distance problem, with downwards, rightwards and diagonal directions as movement choices\n        // (note that diagonal movements do not contribute towards the distance)\n\n        let upstream = upstream_file.content.clone();\n        let current = current_file.content.clone();\n\n        if upstream == current { // compare hashes later\n            return vec![];\n        }\n\n        let mut result = vec![];\n        let diff = TextDiff::from_lines(&current, &upstream);\n\n        // Create(\n        //     String, // path\n        //     String, // file name\n        //     usize, // line\n        //     String // text\n        // ),\n        // Delete(\n        //     String, // path\n        //     String, // file name\n        //     usize // line\n        // ),\n        // Update(\n        //     String, // path\n        //     String, // file name\n        //     usize, // line\n        //     String // text\n        // )\n\n        for change in diff\n            .iter_all_changes()\n            .filter_map(|c| match c.tag() {\n                ChangeTag::Equal => None,\n                _ => Some(c)\n            }\n        ) {\n            result.push(\n                match change.tag() {\n                    ChangeTag::Delete => Modification::Delete(path.clone(), current_file.name.clone(), change.old_index().unwrap()),\n                    ChangeTag::Insert => Modification::Create(path.clone(), current_file.name.clone(), change.new_index().unwrap(), change.to_string()),\n                    _ => panic!()\n                }\n            )\n        }\n\n        result\n    }\n\n    pub fn get_change_container(upstream: &Directory, current: &Directory, path: &Path) -> (Vec<ContainerModification>, Vec<Modification>) {\n        // assume that both current and previous have the same directory names\n        // has to be bfs\n\n        // initialise current state set\n        let mut current_set = HashSet::new();\n        let mut current_map = HashMap::new();\n        for c in &current.content {\n            match c {\n                Content::Directory(d) => {\n                    current_set.insert((d.name.clone(), false));\n                    current_map.insert((d.name.clone(), false), c);\n                },\n                Content::File(f) => {\n                    current_set.insert((f.name.clone(), true));\n                    current_map.insert((f.name.clone(), true), c);\n                }\n            }\n        }\n        //\n\n        // initialise upstream state set\n        let mut upstream_set = HashSet::new();\n        let mut upstream_map = HashMap::new();\n        for c in &upstream.content {\n            match c {\n                Content::Directory(d) => {\n                    upstream_set.insert((d.name.clone(), false));\n                    upstream_map.insert((d.name.clone(), false), c);\n                },\n                Content::File(f) => {\n                    upstream_set.insert((f.name.clone(), true));\n                    upstream_map.insert((f.name.clone(), true), c);\n                }\n            }\n        }\n        //\n\n        // use set differences to determine file and directory creation or deletion\n        let deleted = upstream_set.difference(&current_set).map(|(n, t)| (n.to_string(), *t)).collect::<Vec<(String, bool)>>();\n        let created = current_set.difference(&upstream_set).map(|(n, t)| (n.to_string(), *t)).collect::<Vec<(String, bool)>>();\n        //\n\n        // for all deleted files, log them\n        // for all deleted directories, log them and do the same for all children\n        let mut container_modifications = vec![];\n        let mut modifications = vec![];\n        for (dir_name, is_file) in deleted {\n            if is_file {\n                container_modifications.push(ContainerModification::DeleteFile(path.join(dir_name.clone()).to_string_lossy().to_string()));\n            } else {\n                let p = path.join(dir_name.clone());\n                container_modifications.push(ContainerModification::DeleteDirectory(p.to_string_lossy().to_string()));\n                // traverse all children, add them to result as well\n                let (mut c_m, mut m) = Change::get_change_container(\n                    match upstream_map.get(&(dir_name, false)).unwrap() {\n                        Content::Directory(deleted_d) => { deleted_d },\n                        _ => panic!()\n                    },\n                    &Directory::new(),\n                    &p\n                );\n                container_modifications.append(&mut c_m);\n                modifications.append(&mut m);\n            }\n        }\n        //\n\n        // for all created files, log them\n        // for all created directories, log them and do the same for all children\n        for (dir_name, is_file) in created {\n            if is_file {\n                let p = path.join(dir_name.clone()).to_string_lossy().to_string();\n                container_modifications.push(ContainerModification::CreateFile(p.clone(), dir_name.clone()));\n                // Modification::Create here\n                modifications.append(&mut Change::get_change(p, &File::new(), match current_map.get(&(dir_name, true)).unwrap() {\n                    Content::File(f) => { f },\n                    _ => panic!()\n                }))\n            } else {\n                let p = path.join(dir_name.clone());\n                container_modifications.push(ContainerModification::CreateDirectory(p.to_string_lossy().to_string(), dir_name.clone()));\n\n                let (mut c_m, mut m) = Change::get_change_container(\n                    &Directory::new(),\n                    match current_map.get(&(dir_name, false)).unwrap() {\n                        Content::Directory(d) => d,\n                        _ => panic!()\n                    },\n                    &p\n                );\n                container_modifications.append(&mut c_m);\n                modifications.append(&mut m);\n            }\n        }\n\n        for content in &current.content {\n            match content {\n                Content::Directory(directory) => {\n                    // get the matching upstream directory\n                    // if it doesnt exist, that means the content is new and can be ignored\n                    // we ignore it because we have already logged it in the section above\n                    let p = path.join(directory.name.clone());\n                    let upstream_directory = match upstream_map.get(&(directory.name.clone(), false)) {\n                        Some(u) => {\n                            match u {\n                                Content::Directory(u_d) => { u_d },\n                                _ => panic!()\n                            }\n                        },\n                        _ => { continue; }\n                    };\n                    //\n\n                    let (mut c_m, mut m) = Change::get_change_container(\n                        upstream_directory,\n                        directory,\n                        &p\n                    );\n                    container_modifications.append(&mut c_m);\n                    modifications.append(&mut m);\n                },\n                Content::File(f) => {\n                    let upstream_file = match upstream_map.get(&(f.name.clone(), true)) \n                    {\n                        Some(c) => match c {\n                            Content::File(f) => f,\n                            _ => panic!()\n                        },\n                        None => { continue; }\n                    };\n\n                    modifications.append(&mut Change::get_change(path.join(f.name.clone()).to_string_lossy().to_string(), &upstream_file, &f));\n                }\n            }\n        }\n\n        (container_modifications, modifications)\n    }\n}\n\n#[derive(Debug)]\npub enum Modification {\n    // creation/deletion of lines in files\n    Create(\n        String, // path\n        String, // file name\n        usize, // line\n        String // text\n    ),\n    Delete(\n        String, // path\n        String, // file name\n        usize // line\n    ),\n    Update(\n        String, // path\n        String, // file name\n        usize, // line\n        String // text\n    )\n}\n\n#[derive(Debug)]\npub enum ContainerModification {\n    // creation/deletion of files & folders\n    // TODO : change so only path needed\n    CreateDirectory(\n        String, // path\n        String // name\n    ),\n    DeleteDirectory(\n        String // path\n    ),\n\n    CreateFile(\n        String, // path\n        String // name\n    ),\n    DeleteFile(\n        String, // path\n    )\n}"}},{"File":{"name":"state.rs","content":"use std::fs;\nuse serde::{Deserialize, Serialize};\n\nuse crate::{content::{Content, Directory, File}, error::BonesError, ignore::IgnoreSet};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct State {\n    pub current: Directory,\n    pub upstream: Directory\n}\n\nimpl State {\n    pub fn empty() -> State {\n        State {\n            current: Directory {\n                name: \"\".to_string(),\n                content: vec![]\n            },\n            upstream: Directory {\n                name: \"\".to_string(),\n                content: vec![]\n            }\n        }\n    }\n\n    pub fn create(path: String, ignore_set: &IgnoreSet) -> Result<State, BonesError> {\n        let mut s = State::empty();\n        match State::content_at(path.clone(), path, ignore_set)? {\n            Content::Directory(d) => {\n                s.current = d;\n                Ok(s)\n            },\n            _ => {\n                Err(BonesError::ConfigurationIncorrect)\n            }\n        }\n\n        // fetch upstream\n\n    }\n\n    pub fn content_at(file_name: String, root_path: String, ignore_set: &IgnoreSet) -> Result<Content, BonesError> {\n        // println!(\"started at {root_path}\");\n\n        // get all files at path\n        let paths = match fs::read_dir(format!(\"./{}\", root_path.clone())) {\n            Ok(r) => r,\n            Err(e) => {\n                println!(\"state.rs (content_at) : {root_path} : {e:?}\");\n                return Err(BonesError::FileCantOpen);\n            }\n        };\n\n        let mut directory_contents = vec![];\n\n        // iterate through them all\n        for path in paths {\n            match path {\n                Ok(p) => {\n                    let file_type = p.file_type().unwrap();\n                    let file_name = p.file_name().into_string().unwrap();\n                    let file_path = p.path().to_string_lossy().to_string();\n\n                    if file_name.starts_with(\".\") {\n                        continue;\n                    }\n\n                    if file_type.is_dir() {\n                        if ignore_set.dir_ignore.contains(&file_name) {\n                            continue;\n                        }\n\n                        match State::content_at(file_name, file_path, ignore_set) {\n                            Ok(c) => {\n                                directory_contents.push(c);\n                            },\n                            Err(e) => {\n                                println!(\"Error subtraverse : {e:?}\");\n                            }\n                        }\n                    } else if file_type.is_file() {\n                        if ignore_set.file_ignore.contains(&file_name) {\n                            continue;\n                        }\n\n                        match File::create(file_name, file_path) {\n                            Ok(f) => {\n                                directory_contents.push(Content::File(f));\n                            },\n                            _ => {}\n                        }\n                    } else if file_type.is_symlink() {\n                        // TODO : decide what to do here\n                        if ignore_set.file_ignore.contains(&file_name) {\n                            continue;\n                        }\n                    }\n                },\n                Err(e) => {\n                    println!(\"Traverse error : {e:?}\");\n                }\n            }\n        }\n\n        Ok(Content::Directory(Directory {\n            name: file_name,\n            content: directory_contents\n        }))\n    }\n\n    pub fn serialise_state(self: &State) -> String {\n        serde_json::to_string(self).unwrap()\n    }\n    \n    pub fn deserialise_state(s: String) -> Option<State> {\n        match serde_json::from_str(&s) {\n            Ok(s) => {\n                Some(s)\n            },\n            Err(_) => {\n                None\n            }\n        }\n    }\n}\n"}},{"File":{"name":"main.rs","content":"use std::fs;\nuse std::path::Path;\nuse std::{collections::HashMap, env};\n\nmod error;\nmod ignore;\nmod state;\nmod utils;\n\nmod bones;\nmod commit;\nmod branch;\nmod stash;\n\nmod content;\nmod change;\n\nuse bones::Bones;\nuse change::Change;\nuse content::File;\nuse ignore::IgnoreSet;\nuse utils::generate_tree;\n\nuse crate::commit::{add, commit, push, pull, fetch, cherry, rollback};\nuse crate::branch::branch;\nuse crate::stash::{stash, restore};\nuse crate::state::State;\n\n// add\n// commit {message}\n// push\n// pull\n// fetch\n// branch {name}\n//      will change to that branch\n//      if branch doesnt exist, create\n//      ask to create stash (if changes present)\n// stash {name|optional}\n//      stashes are bound to a branch\n//      optional to have a name\n// restore\n//      select stash to restore\n// rollback\n//      resets to current head\n// cherry {commit hash}\n\npub fn init(_: State, _: Vec<String>) {\n\n}\n\n\npub fn help(_: State, _: Vec<String>) {\n    println!(r#\"This is the Barebones Version Control System.\"#);\n}\n\npub fn about(_: State, _: Vec<String>) {\n    println!(r#\"This is the Barebones Version Control System.\n\nThe best way to learn is to stupidly and\nblindly reinvent the wheel.\n\nBarebones VCS (or just Bones) is a simple\nhobby project, because remaking Git sounded\nfun and interesting.\n\nMost common features like adding,\ncommitting, pushing and pulling, are\nimplemented.\"#);\n}\n\nfn main() {\n    // for change in Change::get_change(\n    //     \"\".to_string(),\n    //     &File { name: \"\".to_string(), content: fs::read_to_string(\"./lorem/mars\").unwrap() },\n    //     &File { name: \"\".to_string(), content: fs::read_to_string(\"./lorem/earth\").unwrap() })\n    // {\n    //     println!(\"{change:?}\");\n    // }\n    // return;\n\n    // println!(\"{:?}\", Change::get_change_container(\n    //     &Directory {\n    //         name: \"test\".to_string(),\n    //         content: vec![\n    //             Content::Directory(Directory {\n    //                 name: \"dolor\".to_string(),\n    //                 content: vec![]\n    //             }),\n    //             Content::Directory(Directory {\n    //                 name: \"sit\".to_string(),\n    //                 content: vec![\n    //                     Content::Directory(Directory {\n    //                         name: \"new_dir\".to_string(),\n    //                         content: vec![\n    //                             Content::File(File {\n    //                                 name: \"smaller.txt\".to_string(),\n    //                                 content: \"\".to_string()\n    //                             }),\n    //                         ]\n    //                     }),\n    //                 ]\n    //             }),\n    //             Content::File(File {\n    //                 name: \"test.txt\".to_string(),\n    //                 content: \"\".to_string()\n    //             })\n    //         ]\n    //     },\n    //    &Directory {\n    //         name: \"test\".to_string(),\n    //         content: vec![\n    //             Content::Directory(Directory {\n    //                 name: \"sit\".to_string(),\n    //                 content: vec![\n    //                     Content::Directory(Directory {\n    //                         name: \"new_dir\".to_string(),\n    //                         content: vec![\n    //                             Content::Directory(Directory {\n    //                                 name: \"small\".to_string(),\n    //                                 content: vec![]\n    //                             }),\n    //                             Content::File(File {\n    //                                 name: \"smaller.txt\".to_string(),\n    //                                 content: \"\".to_string()\n    //                             }),\n    //                         ]\n    //                     }),\n    //                 ]\n    //             }),\n    //             Content::File(File {\n    //                 name: \"test.txt\".to_string(),\n    //                 content: \"\".to_string()\n    //             }),\n    //         ]\n    //     },\n    //     Path::new(\"here\")\n    // ));\n\n    // build all commands\n    type CommandType = fn(State, Vec<String>);\n    let commands: HashMap<String, CommandType> = HashMap::from_iter::<Vec<(String, CommandType)>>(vec![\n        (\"add\".to_string(), add),\n        (\"commit\".to_string(), commit),\n        (\"push\".to_string(), push),\n        (\"pull\".to_string(), pull),\n        (\"fetch\".to_string(), fetch),\n        (\"branch\".to_string(), branch),\n        (\"stash\".to_string(), stash),\n        (\"restore\".to_string(), restore),\n        (\"rollback\".to_string(), rollback),\n        (\"cherry\".to_string(), cherry),\n        (\"help\".to_string(), help),\n        (\"about\".to_string(), about),\n\n        (\"tree\".to_string(), |s, _| {\n            println!(\"{}\", generate_tree(&s));\n        }),\n\n        (\"init\".to_string(), init)\n    ]);\n    //\n    \n    // collect all arguments\n    let arguments = env::args().collect::<Vec<String>>();\n    if arguments.len() <= 1 {\n        help(State::empty(), vec![]);\n        return;\n    }\n    //\n\n    // get current path\n    // (used to be more complicated than this, but keeping it as a relative path just makes more sense now)\n    let path = Path::new(\".\");\n    //\n\n    // get ignorance set\n    let ignore_set = IgnoreSet::create(fs::read_to_string(path.join(\".bones_ignore\")).unwrap_or(\"\".to_string()));\n    //\n\n    // get upstream\n    // return error if not found\n    let upstream_state = match Bones::load(&path) {\n        Some(u) => { u },\n        None => {\n            println!(\"Upstream does not exist, consider running 'bones init' instead.\");\n            Bones::empty()\n        }\n    };\n    //\n\n    match State::create(\".\".to_string(), &ignore_set) {\n        Ok(s) => {\n            for change in Change::get_change_container(&upstream_state.upstream.current, &s.current, &path).1 {\n                println!(\"{change:?}\");\n            }\n\n            // println!(\"Upstream :\\n{}\", generate_tree(&upstream_state.upstream));\n            // println!(\"Current :\\n{}\", generate_tree(&s));\n            fs::write(\"./.bones/upstream\", s.serialise_state());\n\n            match commands.get(&arguments[1]) {\n                Some(c) => {\n                    c(s, arguments[2..arguments.len()].to_vec());\n                },\n                None => {\n                    println!(\"Command not found.\");\n                    help(State::empty(), vec![]);\n                }\n            }\n        },\n        Err(e) => {\n            println!(\"{e:?} error encountered.\")\n        }\n    }\n}\n"}},{"File":{"name":"utils.rs","content":"use crate::{content::Content, state::State};\n\npub fn generate_tree(state: &State) -> String {\n    return fetch_contents(&Content::Directory(state.current.clone()));\n}\n\nfn fetch_contents(c: &Content) -> String {\n    let mut result = vec![];\n\n    match c {\n        Content::Directory(d) => {\n            let mut r = vec![d.name.clone()];\n            if d.content.len() >= 1 {\n                let length = d.content.len() - 1;\n                for (index, i) in d.content.iter().enumerate() {\n                    for (inner_index, line) in fetch_contents(i).split(\"\\n\").enumerate() {\n                        r.push(format!(\" {} {line}\", if index == length { if inner_index == 0 { \"└\" } else { \"\" } } else { if inner_index == 0 { \"├\" } else { \"│\" } }));\n                    }\n                }\n            }\n            result.push(r.join(\"\\n\"));\n        },\n        Content::File(f) => {\n            result.push(f.name.clone());\n        }\n    }\n\n    result.join(\"\\n\")\n}\n"}},{"File":{"name":"bones.rs","content":"use std::{fs, path::Path};\n\nuse crate::state::State;\n\n#[derive(Debug)]\npub struct Bones {\n    // holds\n    //      history.changes\n    //      now.changes\n    //      root\n    //      upstream\n    pub upstream: State\n}\nimpl Bones {\n    pub fn empty() -> Bones {\n        Bones {\n            upstream: State::empty()\n        }\n    }\n\n    pub fn init(path: String) {\n        // .bones/\n        //      history.changes\n        //      now.changes\n        //      root\n        //      upstream\n    }\n\n    pub fn load(path: &Path) -> Option<Bones> {\n        let mut result = Bones::empty();\n\n        result.upstream = State::deserialise_state(match fs::read_to_string(path.join(\".bones/upstream\")) {\n            Ok(data) => { data },\n            Err(_) => { return None; }\n        })?;\n\n        Some(result)\n    }\n}\n"}},{"File":{"name":"content.rs","content":"use std::fs;\n\nuse serde::{Deserialize, Serialize};\n\nuse crate::error::BonesError;\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub enum Content {\n    Directory(Directory),\n    File(File),\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct File {\n    pub name: String,\n    pub content: String,\n}\n\nimpl File {\n    pub fn new() -> File {\n        File {\n            name: \"\".to_string(),\n            content: \"\".to_string()\n        }\n    }\n\n    pub fn create(name: String, path: String) -> Result<File, BonesError> {\n        match fs::read_to_string(path) {\n            Ok(content) => {\n                Ok(File {\n                    name: name,\n                    content: content\n                })\n            },\n            Err(_) => {\n                // println!(\"Error creating file : {e}\");\n                Err(BonesError::FileCantOpen)\n            }\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Directory {\n    pub name: String,\n    pub content: Vec<Content>\n}\n\nimpl Directory {\n    pub fn new() -> Directory {\n        Directory {\n            name: \"\".to_string(),\n            content: vec![]\n        }\n    }\n}\n"}},{"File":{"name":"ignore.rs","content":"use std::collections::HashSet;\n\npub struct IgnoreSet {\n    pub dir_ignore: HashSet<String>,\n    pub file_ignore: HashSet<String>\n}\nimpl IgnoreSet {\n    pub fn create(content: String) -> IgnoreSet {\n        let mut result = IgnoreSet {\n            dir_ignore: HashSet::new(),\n            file_ignore: HashSet::new()\n        };\n\n        // always ignore the .bones directory\n        result.dir_ignore.insert(\".bones\".to_string());\n\n        for line in content.split(\"\\n\") {\n            if line.is_empty() {\n                continue;\n            }\n\n            // doesnt take into account cases like \n            // some_directory// <- double slashes\n            if line.ends_with(\"/\") {\n                let i = line[0..line.len() - 1].to_string();\n                if i.is_empty() {\n                    continue;\n                }\n\n                result.dir_ignore.insert(i);\n            } else {\n                result.file_ignore.insert(line.to_string());\n            }\n        }\n\n        result\n    }\n}\n"}}]}}]},"upstream":{"name":"","content":[]}}
use std::{collections::HashSet, path::PathBuf};

use clap::ArgMatches;

use crate::{change::Change, state::State, utils};

pub struct Commit {
    pub id: Option<u32>,
    pub message: String,
    pub description: String,
    pub change: Change,
    pub timestamp: u128,

    pub author: String
}
impl Commit {
    pub fn serialise(&self) -> String {
        format!("= {} {} {:?} {:?} {}\n{}",
            self.id.map_or("LOCAL".to_string(), |i| format!("{:06x}", i).clone()),
            self.timestamp,
            urlencoding::encode(&self.message).to_string(),
            urlencoding::encode(&self.description).to_string(),
            self.author,
            self.change.serialise_changes()
        )
    }
}


pub fn add(state: State, args: &ArgMatches) {
    // let f: HashSet<String> = HashSet::from_iter(args.get_many::<String>("FILE").unwrap().map(|x| x.to_string()).collect::<Vec<String>>());
    let f = args.get_many::<PathBuf>("FILE").unwrap().map(|x| x.clone()).collect::<Vec<PathBuf>>();

    // f.difference(state.ignore_set);
    for p in f {
        println!("{p:?} : {}", p.is_dir());
    }
}

pub fn commit(state: State, args: &ArgMatches) {
    // push into pending stage
    // update upstream

    // everything after the first line will be generated by Change::serialise_change
r#"= {commit id} {unix timestamp of commit} {message} {description} {author}
+ D "lorem/ipsum/dolor"
+ F "lorem/ipsum/dolor/earth.txt" "earth.txt"
- D "lorem/sit"
=
| "lorem/ipsum/dolor/earth.txt"
+ 3 asdfsdf
+ 5 sfsdf
- 7
| "lorem/ipsum/saturn/txt"
+ 4 lsdfljs"#;
    let message = args.get_one::<String>("message").unwrap().clone();
    let description = args.get_one::<String>("description").map_or("".to_string(), String::clone);

    let commit = Commit {
        id: None,
        message,
        description,
        change: state.get_changes(),
        timestamp: utils::get_time(),
        author: "no_one".to_string()
    };

    state.pending_add(commit);
    // update upstream
    // TODO : only update added files, ignore the rest
    state.update_upstream(&state.track_set);
}

pub fn push(state: State, args: &ArgMatches) {

}

pub fn pull(state: State, args: &ArgMatches) {

}

pub fn fetch(state: State, args: &ArgMatches) {

}

pub fn cherry(state: State, args: &ArgMatches) {
    
}

pub fn rollback(state: State, args: &ArgMatches) {

}

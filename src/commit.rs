use std::{collections::HashSet, fs, path::PathBuf};

use clap::ArgMatches;

use crate::{change::Change, state::State, utils};

pub struct Commit {
    pub id: Option<u32>,
    pub message: String,
    pub description: String,
    pub change: Change,
    pub timestamp: u128,

    pub author: String
}
impl Commit {
    pub fn serialise(&self) -> String {
        format!("= {} {} {:?} {:?} {}\n{}",
            self.id.map_or("LOCAL".to_string(), |i| format!("{:06x}", i).clone()),
            self.timestamp,
            urlencoding::encode(&self.message).to_string(),
            urlencoding::encode(&self.description).to_string(),
            self.author,
            self.change.serialise_changes()
        )
    }
}


pub fn add(_: &mut State, args: &ArgMatches) {
    let f = args.get_many::<PathBuf>("FILE").unwrap().map(|x| x.clone()).collect::<Vec<PathBuf>>();

    let mut result = fs::read_to_string("./.relic/tracked").unwrap().split("\n").map(|x| x.to_string()).collect::<Vec<String>>();
    for p in f {
        // TODO : path.join for this? or concatenating / works?
        result.push(format!("{}{}", p.to_string_lossy().to_string(), if !p.to_string_lossy().to_string().ends_with("/") && p.is_dir() { "/" } else { "" }));
    }
    let _ = fs::write("./.relic/tracked",
        HashSet::<String>::from_iter(
            result
            .into_iter()
            .filter(|x| !x.is_empty())
        )
        .drain()
        .collect::<Vec<String>>()
        .join("\n")
    );
}

pub fn commit(state: &mut State, args: &ArgMatches) {
    // push into pending stage
    // update upstream

    // everything after the first line will be generated by Change::serialise_change
r#"= {commit id} {unix timestamp of commit} {message} {description} {author}
+ D "lorem/ipsum/dolor"
+ F "lorem/ipsum/dolor/earth.txt" "earth.txt"
- D "lorem/sit"
=
| "lorem/ipsum/dolor/earth.txt"
+ 3 asdfsdf
+ 5 sfsdf
- 7
| "lorem/ipsum/saturn/txt"
+ 4 lsdfljs"#;
    let message = args.get_one::<String>("message").unwrap().clone();
    let description = args.get_one::<String>("description").map_or("".to_string(), String::clone);

    let commit = Commit {
        id: None,
        message,
        description,
        change: state.get_changes(),
        timestamp: utils::get_time(),
        author: "no_one".to_string()
    };

    // state.pending_add(commit);
    // update upstream
    (*state).update_upstream(&mut state.track_set.clone());
}

pub fn push(state: &mut State, args: &ArgMatches) {

}

pub fn pull(state: &mut State, args: &ArgMatches) {

}

pub fn fetch(state: &mut State, args: &ArgMatches) {

}

pub fn cherry(state: &mut State, args: &ArgMatches) {
    
}

pub fn rollback(state: &mut State, args: &ArgMatches) {

}
